---
# layout: post
layout: post-custom
title: "拾遗补漏"
---

>**万时定律**，10000小时定律。  
简单来说，要成为某个领域顶尖的专业人才，需要10000小时持续不断的练习。例如小提琴、足球、国际象棋、围棋等领域，无一例外都遵循这个定律。  
技术人员的成长需要对技术的热情和持续不断学习，思考，实践和总结。

## 嵌入式软件的特点和实现方法

### 可剪裁性
在研发嵌入式产品过程中，产品的功能会不断的添加和更新，产品的型号也会越来越多。这时产品的软件研发团队就需要考虑是在*原有的软件版本上修改*还是*全新开发*。

从研发成本上考虑会考虑基于原有软件上修改。

原有软件上功能会越来越多，但一款产品可能只需要其中部分功能，这就要求嵌入式软件系统具有良好**可裁剪**性。

嵌入式系统提供良好的裁剪性，有利于产品开发团队做出更多差异化的产品和低成本的产品（裁剪后的软件系统通常也降低了对硬件的要求）。

通常在一个项目中不会只使用其中一种方法，而是会根据不同场景在不同的层次上同时使用。

#### 静态编译
静态编译主要是通过**条件编译**宏来控制。

为每个特性定义一个编译宏，当产品的特定确定后，在编译时只打开特定特性的编译开关，这样无关的代码就不会参与编译。

有效减少静态编译的软件包体积。

缺陷是必须重新编译代码，减低了代码的可维护性。

**静态编译**是嵌入式软件**可剪裁**性和**可配置**性的一种实现方法，包括对操作系统的剪裁（操作系统也是软件）。

#### 动态库
动态库会将各个功能模型分别编译成动态库，由主进程根据产品的功能需求加载需要的动态库。

优点是不用重新编译，缺陷是实现起来复杂。

动态库是嵌入式软件**可剪裁**性的一种实现方法。

#### 控制函数流程
控制函数流程实现起来类似**静态编译**，只不过是将静态编译时的编译宏改成全局变量判断。

这些全局变量应该在主进程启动时从规格文件获取特性并加载在全局变量中，通过这些特性全局变量控制函数（业务）流程，达到功能裁减的目的。

此方法是前面两种方法的折中，实现简单也不需要重新编译代码。但软件包体积没有减小。


### 可配置性
#### 数据驱动
数据驱动思想是认为**数据易变**，而**逻辑**相对比较**固定**，将数据和逻辑**分离**，使得数据易于修改和扩展。

以MP3播放器为例，使用**数据驱动**可以简化音乐播放器的设计。
- MP3播放器需要根据MP3文件进行音乐播放，不同的歌曲遵循相同的文件格式，播放器只需要根据文件格式进行统一的解析和处理。
- 当需要播放其他类型的音乐时，只需要添加相应的音乐文件和数据表，而不需要修改播放器本身的代码‌

数据驱动通过**定义数据表**控制程序的行为，这些数据表包含控制程序行为的各种参数和条件。

#### 配置表
配置表主要用于存储系统的配置参数，使得系统的行为可以根据不同的配置参数进行调整，从而提高软件的灵活性和可维护性。

配置表是一种数据结构，用于存储系统的各种配置参数。这些参数可以包括但不限于：
- 系统启动参数
- 设备驱动参数
- 通信协议参数
- 定时任务参数
- 用户界面设置
- 系统调试选项


### 高确定性
#### 静态分配资源
静态分配资源是指在系统启动时或编译时预先分配好所需的资源，而不是在运行时动态分配。

这种方法可以确保系统在运行过程中不会因为资源不足而导致不可预测的行为。

应用场景：
- 内存分配：在编译时或启动时**分配**固定的**内存块**，避免运行时的动态内存分配。
- 中断处理：预先**分配**中断处理**所需的资源**，确保中断处理的及时性和可靠性。
- 任务调度：预先**分配**任务所需的**CPU时间**和**内存**资源，确保任务按预定的时间表执行。

#### 状态机
状态机是一种数学模型，用于描述系统的**状态**及其**状态之间**的**转换**。

在嵌入式系统中，状态机常用于管理和控制系统的不同状态，确保系统在不同情况下能够按照预定的逻辑进行切换。


#### 静态任务调度
静态任务调度是指在系统启动时或编译时**预先确定**任务的**执行顺序**和**时间**，而不是在运行时动态调度。

这种方法可以确保任务在预定的时间内执行，提供高确定性的行为。

应用场景：
- 实时系统：确保关键任务在预定的时间内完成，满足实时性要求。
- 多任务系统：管理多个任务的执行顺序和时间，确保系统在多任务环境下的稳定运行。
- 周期性任务：管理周期性任务的执行，如定时采集传感器数据、定期发送心跳信号等。

#### 越界检查
越界检查的主要目的是防止数组、指针或其他**数据结构**类型**超出**其**合法范围**，从而避免潜在的系统崩溃、数据损坏或安全漏洞。

实现方法：
- 编译时检查。
  - 静态分析工具：使用静态分析工具在编译时检测潜在的越界访问。
  - 编译器选项：GCC 编译器的 -fbounds-check 选项可以在编译时插入边界检查代码。
- 运行时检查。
  - 手动检查：在代码中显式地添加边界检查逻辑。
  - 使用安全库：使用提供边界检查功能的库，如 C++ 标准库中的 std::vector，它在访问元素时会自动进行边界检查。
  - 硬件支持：一些嵌入式系统提供了硬件级别的边界检查功能，例如内存管理单元（MMU）可以检测和防止越界访问。

### 可靠性
#### 容错技术
容错技术是指系统在出现故障时仍然能够继续正常工作的能力。通过设计和实现容错技术，可以确保系统在部分组件或子系统失效的情况下，仍然能够完成预定的任务。

实现方法：
- 错误检测与纠正。
- 故障隔离。
  - 将系统划分为多个独立的模块，确保一个模块的故障不会影响其他模块的正常运行。
- 故障恢复。
  - 设计故障恢复机制，如重启模块、切换到备用系统、重试操作等，确保系统在故障发生后能够恢复正常运行。
- 冗余设计。
  - 通过增加冗余组件（如备用硬件、冗余软件模块）来提高系统的容错能力。

#### 余度技术
余度技术是指通过增加**冗余组件**或**路径**来提高系统的可靠性和可用性。

冗余可以是硬件冗余、软件冗余或信息冗余。

实现方法：
- 硬件冗余：增加备用的硬件组件，如双CPU系统、冗余电源、冗余存储设备等。
- 软件冗余：实现多个独立的软件模块或路径，确保在一个模块或路径失效时，其他模块或路径可以接管任务。
- 信息冗余：通过增加冗余信息（如校验码、备份数据）来提高数据的可靠性和完整性。

#### 鲁棒性设计
鲁棒性设计是指系统在面对不确定因素、异常输入或环境变化时，仍然能够保持稳定和可靠的能力。

鲁棒性设计的**目标**是使系统能够在各种**不利条件**下**正常工作**。

实现方法：
- 输入验证：对所有外部输入进行严格的验证，确保输入数据的有效性和合法性。
- 异常处理：设计健壮的异常处理机制，捕获并处理运行时可能出现的各种异常。
- 容错设计：结合容错技术和余度技术，提高系统的容错能力和可靠性。
- 环境适应性：在不同的环境条件下进行测试，确保系统在各种环境下都能正常工作。
- 资源管理：合理管理内存、CPU等资源，避免资源竞争和死锁。
- 性能优化：优化代码和算法，提高系统的响应速度和稳定性。
- 模块化设计：将系统划分为多个独立的模块，确保每个模块的功能单一且易于测试和维护。

### 安全性
#### 编码标准
#### 安全保障机制
#### FMECA

## 待研究的点

### 数据流图与系统流程图的区别

1. 并行性有区别。
   数据流图的处理过程**可并行**；流程图在某一时间点只能处理一个处理过程。
2. 展示目的不同。
   数据流图展示的是系统的**数据流**；流程图展示的是系统的**控制流**；
3. 计时标准不同。
   数据流图展示的是系统的全局处理过程，过程之间遵循不同的计时标准；流程图中处理过程遵循的是一致的计时标准。
4. 阶段不同。
   数据流图适用于**系统分析**中使用的逻辑建模阶段；流程图适用于**系统设计**中的物理建模阶段。

### 基于构件的软件开发方法及其应用

- 项目摘要
- 项目背景
- 技术分析
- 实施过程
- 结论与思考

#### 使用spring制作可依赖的jar包

之前使用过maven-archetype-quickstart构建了一个项目，编写了一些工具类方法并利用maven-assembly-plugin打包成了普通jar包，并可被其他系统引入。

而现在对maven-assembly-plugin的打包流程以及相关配置以及很模糊了，翻看之前的书签也没法重新梳理清楚。

其实本质就是想和现在spring开发通过maven引入jar包实现相关功能的一样。

那么是否有更简单的方法，或者重新理清楚maven-assembly-plugin的使用方式。

#### 现在的技术能力如何进行构建开发和实践

1.利用spring进行jar包开发。对独立性抢、常用性、耦合性低、业务清晰的功能进行单封装，并制作成可供依赖的jar包，提高代码复用率，缩短开发周期，减少开发成本，便于维护和管理。是否符合构件开发？

2.基于一个父项目下，划分多个子模块的工程是否也符合构件开发？

3.有什么其他比较容易理解或符合认知的构件项目？

--------
## SOLID设计原则
### 5个原则
**SOLID**是5个设计原则的单词首字母缩写。

#### Single responsiblity principle（单一职责原则）
一个类或模块只负责一个职责或功能。

#### Open-Closed principle（开闭原则）
对模块、类、方法拓展开放，对修改关闭。

#### Liskov substitution principle（里氏替换原则）
子类能够替换父类对象出现的任何地方，并且保证原来程序的逻辑行为不变。

#### Inteface segregation principle（接口隔离原则）
为各个类建立它们需要的专门接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。例如UserService接口有登录、查询、注册等一些列方法，而删除操作是慎重的，且可能是特定系统才拥有的功能，所以可以专门定义一个RestrictedUserService接口，专门实现删除功能。具体调用方可以根据实际需要实现各自需要的一个或一组接口。

#### Dependency inversion principle（依赖倒置原则）
- 高层模块不应依赖于底层模块，二者都应该依赖于抽象。即：高层模块和底层模块共同依赖同一个抽象，面向抽象类或接口编程。
- 抽象不应该依赖实现细节，细节应该依赖抽象。

传统的从上到下设计方式是逐级依赖，即高层模块->级模块->底层模块。这样高层模块就依赖底层模块了，当某一模块需要修改，可能牵一发而动全身，影响较多不易维护。

而**依赖倒置**，就是高层模块->抽象层<-底层模块，使得它们同依赖抽象层，这样减少了类之间的耦合性，不同模块都可独立针对接口/抽象进行并行开发，可维护性大大增加。

--------
## 布隆过滤器
### 目的
解决当需要存储大量数据时，如何以最少的内存判断某个元素**是否存在于集合中**。

### 设计理念
**尽可能节省空间的情况下快速判断元素是否存在**，即使这意味着引入一定的误报风险。

### 应用场景
布隆过滤器设计的场景更倾向于**优化查询效率**和**节省存储空间**。允许某个元素“可能存在”而不是“完全存在”，就能大幅节约存储空间，尤其适用于对查询正确性要求不苛刻的场景。

布隆过滤器应用于缓存系统、垃圾邮件过滤、网页URL去重、集合重复元素判别、查询加速等多个场景。

### 基本原理
布隆过滤器的核心思想可以简化为**位数组**和**多个哈希函数**的结合。

1. 位数组  
   布隆过滤器使用一个长度为 m 的位数组，每一位都初始化为 0。这些位将用于表示元素的存在情况。

2. 多个哈希函数  
   布隆过滤器配备了 k 个独立的哈希函数。每个哈希函数都会为输入的元素生成一个 0 到 m-1 之间的索引值，也就是将元素“映射”到位数组中的某个位置。  
   通过多个哈希函数，**一个元素**会影响位数组中的**多个位置**，从而**降低哈希冲突**的风险。

3. 添加元素  
   当添加一个元素到布隆过滤器时，k个哈希函数会为该元素生成k个不同的索引值，并在位数组中将k个位置设置为1。
   
4. 查询元素  
   查询元素是否存在时，k个哈希函数会生成该元素的k个位置，并检查位数组中这个k个位置是否都为1。如果都为1，则表示元素**可能存在**；如果有任何一个位置为0，则确定元素不存在。

5. 误报率  
   布隆过滤器的一个关键特性是**可能误报**。因为位数组大小是有限的，多个元素可能会被不同的哈希函数映射到相同的位置上，导致某些不在集合的元素被误认为存在。  
   误报率与位数组的长度m，哈希函数的数量K，以及集合中的元素n有关。合理选择这些参数，可以在误报率和存储效率间做出权衡。

### 优缺点
优点：
1. 查询速度快。
   - 只需检查元素被映射在位数组中的几个位置即可。
2. 高效节省存储空间。  
   - 布隆过滤器并不存储元素本身，使用位数组占位，使用的存储空间更少。
3. 不漏报。  
   - 如果某个元素不在集合中，就一定不存在。

缺点：
1. 有一定的误报率。
   - 可能会错误地判断某个不在集合中的元素存在。
2. 不可删除（删除困难）。
   - 因为位数组的位可能被多个元素**共用**，因为误报的特性，布隆过滤器无法保证删除的元素的确存在于集合中。

### 总结
- **以小博大**查询快  
  - 使用少量的存储空间，来获得对大量数据进行快速查询的效率。
- **分而治之**冲突小  
  - 使用多个不同的哈希元素对元素处理，生成不同的索引位置，降低哈希冲突。
- **位理万机**可误报不删除  
  - 多个元素可能被映射到同一个位置，从而出现误报，也正因此，一般不删除布隆过滤器中的元素。

资料引用：
<a href="https://zhuanlan.zhihu.com/p/720288602" target="_blank">https://zhuanlan.zhihu.com/p/720288602</a>

--------
## 缓存穿透、缓存击穿、缓存雪崩

### 1.缓存穿透
缓存穿透是指要查询的**key不在**缓存中，或**key不在**缓存**也不在数据库**中，导致大量的请求直接压到数据库中的情况。

解决方案：
1. 缓存空对象，即缓存null。
   这个方案存在2个问题：
   - 不存在的key理论上是无限的，这会导致内存占用过多，缓存性能下降。
   - 若数据库突然写入这类key的数据并未更新到缓存时，会导致缓存期间数据不一致。
2. 使用布隆过滤器等方式，对key值进行过滤，仅允许系统存在的key进行后续操作。
   
### 2.缓存击穿
缓存击穿是指缓存中的**热点数据**key过期，在过期的瞬间会有大量的请求（高并发）过来直接访问数据库，导致数据库压力增加。

解决方案：
1. 缓存预热：在程序启动时或高峰期时间通过定时任务提前将热点数据更新到缓存中，避免高峰期间的大量请求访问到数据库。
2. 加锁控制：利用分布式锁使得同一时间只有一个请求能访问到数据库并更新缓存，这样其他请求线程只能等待锁释放，得到锁之后已经可以读取到缓存中的数据
3. 设置数据永不过期：根据业务上的常用数据，可以酌情设置数据永不过期。
   
### 3.缓存雪崩
缓存雪崩是指缓存中大量key在**同一时间过期**，从而导致大量请求访问到数据库中，数据库随时可能宕机的现象。

解决方案：
1. 设置不同过期时间：给不同的key设置不同的过期时间，使失效时间尽量**分散**，避免同一时间过期。
2. 加锁或排队：缓存失效后，通过排它锁或队列的方式控制数据库写缓存的线程数量，使得操作串行化。
3. 多级缓存方案：酌情设置多级缓存。使得过期key可以从二级或多级缓存中读取到数据。
4. 限流措施：使用令牌桶等限流算法控制请求数量，减少服务压力。

### 总结
- 过滤防穿透。
- 预热防击穿。
- 雪崩要排队、分散限流降风险。

--------
## 数据库设计的规范化和反规范化

为了更好的理解数据库设计的规范化和反规范化，我们需要先弄清楚什么是函数依赖，以及函数依赖的分类，而要理解函数依赖，就要先明白什么是关系模式。

### 一、基本术语

#### 属性（Attribute）
- 在现实世界中，要描述一个事务常常取若干特征来表示。这些特征称为属性。
- 例如学生通过学号、姓名、性别、系别、年龄、籍贯等属性来描述。
  

#### 域（Domain）
- 每个属性的取值范围对应一个值的集合，称为该属性的域。
- 例如，学号的域是6位整型数；姓名的域是10位字符；性别的域为{男，女}等。


#### 超键（Super Key）
- 超键是一组属性。能够唯一标识表中每一行记录。
- 超键可以包含多余属性，即便不是必须的，结合起来也可以唯一标识记录。


#### 候选键（Candidate Key）
- 候选码是最小的超键。即从超键中移除任何属性后，它就不再能唯一标识表中的每一行记录。


#### 主键（Primary Key）
- 若一个关系中有多个候选码，则选定其中一个作为主键。
- 主键也是最小的超键。一旦选定，应尽量避免更改。


#### 主属性（Prime Attribute）
- 包含在任何候选码中的属性称为主属性。


#### 非主属性（Non-Prime Attribute）
- 不包含在任何候选码中的属性称为非主属性。


#### 外键（Foreign Key）
- 如果关系模式R中的属性或属性组不是该关系的码，但它是其它关系的码，那么该属性集对关系模式R而言是外键。
- 例如，客户与贷款之间的借贷联系c_1(c_id,loan_no)，属性c_id是客户关系中的键，所以c_id是外键；属性loan_no是贷款关系中的键，所以loan_no也是外键。

#### 全码（All-Key）
- 关系模型的所有属性组是这个关系模式的候选码，称为全码。
- 例如，关系模式R(T,C,S)，属性T是教师，属性C是课程，属性S表示学生。假设一个教师可以讲授多门课程，某门课程可以由多个教师讲授，学生可以听不同教师讲授的不同课程，那么，要想区分关系中的每一个元组，这个关系模式R的码应为全属性T、C和S。

### 二、关系模式

数据库的关系模式是关系型数据库中用于描述**数据库结构**和**数据**之间**关系**的一种方式。

它是对数据库关系（表）的逻辑结构进行定义，形式化表示为：`R(U,D,dom,F)`。

形式化的表示可以帮助设计者规范地描述数据库中的数据结构，以及数据之间的逻辑关系。这有助于确保数据的完整性和准确性，并为数据库的查询和操作提供一个清晰的基础。

通常，可以将关系模式简记：`R(U)` 。

- R：表示关系的名称，代表数据库中的一张表或关系。
- U：表示关系R的属性集合。这些属性定义了关系中的列。
- D：表示属性集合U中每个属性的域或数据类型集合。域是对属性可能值的限制，确保每个属性的值都属于其指定的数据类型。
- dom：表示属性集合U中每个属性的值域，是属性到域的映像集合。
- F：表示关系R的函数依赖集合。

举个例子，假设我们有一张`学生成绩表`，存储的是学生信息和他们的成绩。用关系模式`R(U,D,dom,F)`来描述，其中：
- R：学生成绩
- U：{学号，姓名，课程，成绩}
- D：{整数，字符串，字符串，浮点数}
- dom：
    - 成绩：分数，例如90.5
    - 课程：课程名称，例如数学
    - 姓名：学生的名称，例如张三
    - 学号：具有唯一性的studentId，例如123456
- F：{学号->姓名，（学号，课程）->成绩}
  
以上关系模式，可以简记为：`学生成绩(学号，姓名，课程，成绩)`

### 三、数据依赖

#### 函数依赖

在上述关系模式的说明中，我们提到了函数依赖F，数据库中的函数依赖是描述关系型数据库中表的**属性之间**相互依赖**关系**的概念。

它反映了表中数据属性之间的逻辑关系，即一个属性或属性集是否能够决定另一个属性或属性集的值。

假设现有如下关系模式`学生表`：

|学号|姓名|专业名|性别|出生日期|本学期学分|
|-|-|-|-|-|-|
|42014601|李梦|信管|女|2000-02-11|24|
|42014602|冯小羽|电商|男|2001-08-07|24|
|42014603|朱秀淳|财会|女|2001-09-07|24|
|42014604|曾敏能|物流|男|2001-10-18|24|

`学生成绩表`：

|学号|姓名|课程号|成绩|
|-|-|-|-|
|42014601|李梦|020114|100|

##### 平凡函数依赖
- 定义：设一个关系`R(U)`，`X`和`Y`为属性集U的一个子集，当X->Y时，如果Y ⊂ X，那么称：`X->Y`为**平凡函数依赖**。
- 例如：`(学号，姓名) -> 姓名`。

##### 非平凡函数依赖
- 定义：设一个关系`R(U)`，`X`和`Y`为属性集U的一个子集，若X->Y时，Y ⊄ X，那么称：`X->Y`为**非平凡函数依赖**。
- 举例：`(学号， 课程号) -> 成绩` 。

##### 完全函数依赖
- 定义：在`R(U)`中，X、Y为U的子集，若X->Y，且对X的任意一个**真子集Z**来说，Z->Y都不成立。那么称：`X->Y`为**完全函数依赖**。
- 举例：`(学号， 课程号) -> 成绩`。

*(学号，课程) -> 成绩。学号和课程单独拿出来都不能决定成绩。所以说 `成绩` 完全依赖于 `(学号，课程)`。*


##### 部分函数依赖
- 定义：在`R(U)`中，X、Y为U的子集，若X->Y，存在一个X的**真子集Z**，使得Z->Y，那么`X->Y`为**部分函数依赖**。
- 举例：`(学号，课程号) -> 姓名`

##### 传递函数依赖
- 定义： 在一个关系模式`R(U)`中，X、Y、Z为属性集U上的子集，如果X->Y，Y不能反推出X，且Y->Z，这时候X也可以推出Z，即 `X -> Y -> Z`，则`X->Z`为**传递函数依赖**。
- 举例：`学号 -> 班级`，`班级 -> 班主任`，所以`学号 -> 班主任`为传递函数依赖。

资料： [快速理解数据库函数依赖](https://blog.csdn.net/weixin_62714329/article/details/129806085)

##### 多值依赖
定义：
- 存在关系模式`R(U)`，X、Y、Z是U的子集，并且 Z = U-X-Y。
- **当前仅当**对R(U)的任一关系r，给定的一堆`(x,z)`值，有一组`y`的值，这组值仅仅决定于`x`的值而与`z`值无关。则**多值依赖** X->Y成立，

举例：  

`学生选课表(学号，专业，课程)`中，假设每个专业有多个学生，有一组必修课，设同专业内所有学生选修的必修课相同。

按照语义，给定一堆`(专业, 课程)`的值，有一组`(学号)`的值仅仅决定于`专业`，与`课程`无关。则称`专业->学号`是**多值依赖**。简单理解就是**一对多**关系(1:n)。

**其实还有一个方法可以判断是否存在多值依赖**

- 找到`专业`属性M的**相同**值和`学号`属性S的**不同**值的任意两个元组，**交换**他们的`课程`C值。
- 重新组成的元组如果可以在这个表内找到，那么就存在多值依赖。

##### 连接依赖

一个关系模式(表)`R(U)`可以分解为几个子表`R(A)`,`R(B)`，如果将几个子表连接起来以后仍然是原来那个表`R(U)`。则称原来的那些属性之间具备``连接依赖``。


### 四、规范化

数据库设计规范化（Database Nomalization）是数据库设计中的一个重要方法，旨在优化数据库结构：
- 提高数据的**一致性**和**完整性**。
- **减少**数据**冗余**。
- 增强数据**修改**的**灵活**性。
- **降低**数据**查询的复杂性**。
  
规范化通常涉及将**大表**拆分为更小、更专门的**小表**，并通过定义**表之间**的**关系**来**连接**这些表。

通常可以通过判断分解后的模式达到几范式来评价模式规范化的程度。范式从低到高依次为：

1. 第一范式（1NF）
2. 第二范式（2NF）
3. 第三范式（3NF）
4. 巴斯-科恩范式（BCNF）
5. 第四范式（4NF）
6. 第五范式（5NF）
7. 第六范式（6NF）

在实际应用中，**3NF**已经足够满足大多数数据库设计的需求。

#### 第一范式（1NF）

- 定义： 数据表中的每一列都是**不可分隔**的数据项，不包含重复列。
- 目的： 消除重复数据，确保每个字段都是原子性，减少数据冗余。

若存在学生表如下：

|学号|姓名|课程|
|--|--|--|
|1|Alice|Math,English|
|2|Bob|Math,Science|
|3|Charlie|Art,History|

Courses是学生所选的所有课程，这种表设计使得查询某课程被哪些学生选择变得复杂，并且在新增课程、取消选课时也要分解Courses字段才能进行处理。

#### 第二范式（2NF）

- 定义： 在1NF的基础上，**非主键**列**完全依赖**于**主键**，而不是主键的一部分。
- 目的： 消除**部分函数依赖**，进一步减少数据冗余。

例如供应商和它所提供的零件信息，关系模式和函数依赖集F如下：
- 供应商信息表`Supplier(Sno, Sname, Status, City, Pno, Qty)`
- 函数依赖F = {`Sno->Sname`, `Sno->Status`,`Status->city`, `(Sno,Pno)->Qty`}

具体关系如下表所示:

|Sno|Sname|Status|City|Pno|Qty|
|--|--|--|--|--|--|
|S1|精益|20|天津|P1|200|
|S1|精益|20|天津|P2|300|
|S1|精益|20|天津|P3|480|
|S2|盛锡|10|北京|P3|500|
|S3|东方红|30|北京|P2|280|
|...|...|...|...|...|...|


分析：
- 每列都是不可再分的数据项，满足1NF。
- 函数依赖：
  - `Sno -> Sname`, 
  - `Sno -> Status`, 
  - `Status -> city`, 
  - `(Sno,Pno)-> Qty`
- 候选键：
  - `(Sno, Pno)`

存在部分函数依赖：`(Sno, Pno) -> (Sname, Status)`。

`Sno`可以单独推断出`(Sname, Statu)`，这就导致其存在插入异常和删除异常的问题：
- 插入异常：是指按照关系模式实体完整性不能取空值或部分取空值。
  - 由于候选码只有一个，所以`(Sno,Pno)`也是主码。这样当某个供应商的`Pno`未提供，则不能插入数据。
- 删除异常：
  - 若供应商S3的P2零件销售完以后不再售卖，那么应删除元组，可S3又是客观存在的，不能因此删除。

为了消除部分函数依赖，我们可以将SPART关系分解为：
- `SupplierInfo(Sno, Sname, Status, City)`
- `Part(Sno, Pno, Qty)`

分解后的关系模式`Supplier`的码为`Sno`，非主属性`Sname`，`Status`，`City`完全依赖于`Sno`，所以属于**2NF**；

关系模式`Part`的码为`(Sno,Pno)`，非主属性`Qty`完全依赖于码，所以也属于**2NF**。

#### 第三范式（3NF）

- 定义：在2NF的基础上，**消除**非主属性之间的**传递依赖**，即任何**非主键列**都**不依赖**于其它**非主键**列。
- 目的：消除**传递依赖**，提高数据表的稳定性和一致性。

在满足了2NF之后，继续分析可以发现，关系`SupplierInfo`中存在**传递函数依赖**。
- `Sno->Status`和`Status->City`

导致其存在修改操作的不一致性问题：
- 如Status=20对应的City从天津搬到了上海，则有可能导致一些Status=20的数据被修改，而另一些不被修改，导致数据产生不一致性。
  
为了解决这个问题，就需要3NF。将`SupplierInfo`进一步分解：
- `Supplier_1(Sno, Sname, Status)`
- `Supplier_2(Status, City)`


#### 巴斯-科德范式（BCNF）

- 定义：在3NF的基础上，要求任何**非主键**列**不依赖**于**主属性**的**子集**。
- 目的：消除3NF中**主属性**对码的**部分依赖**和**传递依赖**。
  
假设：(这个例子可能并不够贴切)
- 某公司有若干仓库，
- 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
- 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。
- 每种物品在每个仓库中都有对应的数量。

表格数据如下：

|仓库|管理员|物品|数量|
|-|-|-|-|
|上海仓|张三|iPhone|30|
|上海仓|张三|iPad|20|
|广州仓|李四|小米13|50|
|北京仓|李四|华为Mate|30|

那么关系模式 `仓库表(仓库，管理员，物品名，数量)` 属于哪一级范式？

分析：
- 函数依赖：
  - `(仓库,物品) -> (管理员, 数量)` 
  - `(管理员, 物品) -> (仓库,数量)`
- 候选键：
  - `(仓库, 物品)` 
  - `(管理员，物品)`
- 主属性：
  - `仓库`
  - `管理员`
  - `物品名`
- 非主属性：
  - `数量`

非主属性完全依赖于候选键，**不存在**非主属性对候选键的**部分函数依赖**（满足2NF），也不存在**传递依赖**，所以它满足**3NF**。

但这个表存在如下问题：
1. 增加一个仓库，但没有存放物品，管理员信息也无法插入。
2. 清空仓库中的所有物品，同时把仓库、管理员信息也清掉了。

这是因为主属性`管理员`对候选键`(仓库，物品)`存在部分依赖，或者说`仓库`对`(管理员, 物品)`存在部分依赖，继续拆分表格来满足BCNF：
- `仓库(仓库名，管理员)`
- `库存(仓库，物品，数量)`


#### 第四范式（4NF）

- 定义：在满足3NF基础上，**消除**非平凡的**多值依赖**。
- 目的：处理表中**多**个**独立存在**的**多值关系**。

假设存在下表：

|学生编号|选课|爱好|
|--|--|--|
|1|数学|篮球|
|1|数学|羽毛球|
|1|英语|篮球|
|1|英语|羽毛球|

在该表中，候选键为`(学生编号,选课,爱好)`，即全部属性都是主属性，且不存在函数依赖，所以它是满足BNCF。

但是由于`学生编号`与`选课`之间，`学生编号`与`爱好`之间分别存在多值依赖，且`选课`和`爱好`之间没有任何关系，所以这里存在数据冗余。每多一个选课都要添加2条记录（篮球和羽毛球）。

4NF的目的就是为了消除这种数据冗余，即**消除**关系中的**多对多**关系，将其**拆分为**多个**一对多**关系。

我们将上表拆分成两张表：
- `S_C(StudentId,Course)`
- `S_H(StudentId,Hobby)`
  
#### 第五范式（5NF）

- 定义：在4NF基础上，处理半依赖和连接依赖。
- 目的：保证数据表中没有隐含的依赖关系。

在4NF的例子中，如果补充一点约束：只有爱好为篮球的学生才可以选择数学和语文，只有爱好为羽毛球的学生才可以选择英语和化学。

此时学生编号、爱好和选课三个属性之间任意两个属性都存在多值约束，此时这三个属性就变成了连接依赖，不存在多值依赖，也就自然满足了4NF，而在4NF基础上，进一步消除其不由候选码隐含的连接依赖，就得到了5NF。

**消除其不由候选码隐含的连接依赖**：保证不存在任何依赖属性不为候选码的连接依赖。

例如上面所述的关系中，候选码是(学生编号，选课，爱好)，而在其连接依赖中：
- 学生编号->选课和学生编号->爱好之间的连接属性为学生编号；
- 爱好->选课和学生编号->爱好之间的连接属性为爱好；
- 爱好->选课和学生编号->选课之间的连接属性为选课；

可见它们的连接属性都不是候选码，所以不满足5NF。

为了使其满足5NF，我们需要针对其连接依赖进行拆分：
- R1(学生编号,选课)。
- R2(学生编号,爱好)和R3(选课,爱好)。

#### 总结

|范式|解析|
|--|--|
|1NF|每一列都不可分割|
|2NF|消除**部分依赖**|
|3NF|消除**传递依赖**|
|BCNF|消除主键对码的部分依赖和传递依赖|
|4NF|消除**多值依赖**|


### 五、反规范化

在关系模式的**规范化**过程中，会导致**关系**的概念越来越**单一化**，在响应用户查询时，往往需要涉及**多表**的**连接**操作，导致查询**性能下降**。

为此需要对关系模式进行修正，对部分影响性能的关系模式进行处理。包括分解、合并、增加冗余属性等。这种修正称为反规范化设计。

反规范化设计通过有意地违反数据库设计中的范式原则，将**数据冗余**存储在多个表中，通过**减少**表之间的**连接**来提高查询性能。

反规范化设计不应与从未进行过标准化的数据库相混淆。常见的反规范化操作有：
- 列：
  - **冗余列**：在多个表中存储相同的列，以避免连接操作。
  - **派生列**：将需要计算的列存储在表中，以避免计算开销。
- 表：
  - **表重组**：将多个表合并成一个表，以减少连接操作。
  - **表分割**：
    - 水平分割
    - 垂直分割

#### 总结
- 冗余**相同列**，派生**计算列**，减少连接与计算。
- 眼光从列放到表:
  - **表多**可合并**重组**。
  - **量多**可行列**分割**。
    - 行分割分维度分压力，
    - 列分割列主码分不同。
  

反规范化设计会在数据库中形成数据冗余，为解决**数据冗余**带来的**数据不一致**问题，设计人员往往需要采用**额外数据同步**的方法来解决数据不一致性。常见的方法有：

  - 事务控制：通过事务机制确保数据修改操作的原子性、一致性、隔离性和永久性。
  - 定期批量处理同步：通过定时批处理程序定时将相关表的冗余数据进行更新，确保数据一致性。
  - 触发器同步：是指在数据修改操作发生时自动触发响应的更新操作，保持数据一致性。


#### 冗余列

#### 派生列

#### 表重组

#### 表分割

表分隔是指将一个大表根据某些特定条件分隔成多个小表。每个小表只包含部分数据，但这些小表共同构成原来的大表。

这种方法可以有效地利用分布式数据库系统的特性，通过将数据分布在不同的服务器上，可以显著地提高查询性能和数据处理能力。

##### 水平分割

水平分割是根据数据行的特点进行分割，分割之后所得的所有表的结构都相同，而存储的数据不同。

例如我国的身份证号码若放在一个表中，由于我国人口众多，因此数据量很大，进行身份查询的效率会很低。这是可以按省份对它进行水平分割，把不同区域的身份信息存储在不同的表中，查询时只需根据省份代码查询相应的表，显著提高查询效率。

水平分割会增加应用的复杂度，特别是汇总数据时需要从不同的表或库中合并。有时候这种复杂性会超过它所带来的有点因此，综合考量表中数据具备很好的独立性时，就适合采用这种办法。

##### 垂直分割

垂直分割是根据数据列的特点进行分割，分割之后所得的所有表都含有主码列外其余列都不相同。

一般在一个表中某些列常用，而某些列不常用时采取垂直分割，把常用列和不常用列分开存储，从而提高查询效率。自然其缺点是若需汇总数据，则需要使用类似join的操作进行合并。

--------
## Redis

Redis是一个高性能的键值存储，它支持多重丰富的数据结构。每种结构都有其特定的用途和底层实现。

### Redis支持的八种数据类型

表格举例Redis常用的数据类型与业务功能对照：

|数据类型|存储的值|可实现的业务功能|
|--|--|--|
|String|字符串、整型或浮点数|用户帖子的评论计数器|
|List|列表|支持粉丝列表功能；每个用户的发布/订阅列表可以表示为一个列表|
|Set|无序集合|每个用户的好友可以表示为一个集合（共同好友功能）；每个帖子的标签也可以表示为一个集合|
|Hash|包括键值对的无序散列表|用户信息的结构化存储|
|ZSset|有序集合|排行榜功能|


#### 1.字符串（String）

文本、数字、二进制数据等。它在Redis内部以动态字符串（SDS，Simple Dynamic String）的形式存储，以节省内存。

#### 2.哈希（Hash）

hash是键值对的集合，适合表示**对象**的属性。最常用的是存储对象。内部实现主要有2种：

- 压缩列表（ziplist）：当哈希数量较少且每个键值对的长度较短时使用。
- 哈希表（hashtable）：当哈希数量增多或其中某个键或值变长后，自动转为哈希表。

#### 3.列表（List）

列表是一组有序的字符串，可以从列表的头部或尾部添加或删除元素。内部实现有2种：

- 压缩列表（ziplist）：元素数据量较少且每个元素较短时使用
- 双向链表（LinkedList）：元素数量较多时，会自动转为双向链表。

#### 4.集合（Set）

集合是无序且唯一的字符串集合。内部采用哈希表（hashtable）实现。哈希表的键是集合的值，值是null。

#### 5.有序集合（ZSet / Sorted Set）

有序集合类似Set，但每个元素都会关联一个分数（Score），元素按分数排序。内部使用一种结构：跳表和哈希表。

- 跳表（skiplist）：快速实现范围查询和排序
- 哈希表（hashtable）：快速定位元素

#### 6.位图（BitMap）

位图将字符串值视为一个位数组，可以进行位操作。内部存储采用字符串，最大长度可达512MB。

- 字节数组（byte array）：实际存储位图数据的结构，是一个连续的内存区域。

#### 7.HyperLogLog

HyperLogLog是基数估算数据结构，用于估算不重复元素的数量。利用概率算法实现，误差率约0.81%。用于大规模数据去重计数。

- 稀疏矩阵（Sparse Representation）：当元素少时，用压缩方法存储。
- 密集矩阵（Dense Representation）：当元素多到一定程度时，转为密集表示。


#### 8.地理空间（Geospatial）

Redis的地理空间拓展允许存储地理坐标，并提供地理范围查询、距离计算等功能。内部试用有序集合（Sorted Set）数据类型实现，利用GeoHash编码。

- GeoHash编码：将经纬度编码为字符串，保证地理位置靠近的两个编码也是靠近的。
- 跳表（skiplist）和哈希表（hashtable）：与有序集合共享的实现，支持半径查询和排序。

### Redis的分布式架构

#### 主从模式

Master-Slave模式是最简单的一种分布式架构。有一个主节点和一个或以上的从节点。

原理：
- 主节点：负责处理写操作（写入、更新、删除）
- 从节点：负责处理读操作，同时从主节点同步数据，保证数据一致性。

优点：
- **读写分离**，提高读性能，减少写节点的压力。
- 主节点故障时，从节点可以升级为主节点，保证服务的高可用性。

缺点：
- **单点故障**：如果**主节点**挂了，需要手动切换从节点为主节点。
- **写**操作压力**集中**在主节点，拓展性有限。

#### 哨兵模式

Sentinel模式是主从模式的扩展，通过监控主/从节点的状态，自动将从节点升级为主节点，保证服务的高可用性。在主从模式的基础上增加了**监控**和自动**故障转移**功能。

原理:
- 哨兵节点：独立于主/从节点的监控进程，负责监控主/从节点的状态。
- 当主节点故障时，哨兵节点会自动选举一个从节点作为新的主节点，并通知客户端更新连接信息。

优点：
- 自动故障转移，减少人为干预。
- 提高系统的高可用性和稳定性。

缺点：
- 哨兵节点自身也可能有**单点故障**，需要配置多个哨兵节点互相监控。
- 实现相对复杂，需要额外的配置和维护。
  
**总结**
- 一主多从，读写分离又分工。主从切换要手动，哨兵监控来捉刀。
- 哨兵额外需配置，又怕单点出问题。
- 并发高又数据大，集群分片用哈希。

#### 集群模式

Cluster是Redis提供的一种更复杂、更强大的分布式解决方案，适用于大规模数据和高并发场景。

原理：
- 数据分片（Sharding）：将数据分布到多个节点上，每个节点只存储一部分数据。
- 每个节点既可以是主节点也可以有对应的从节点，形成一个集群。

优点：
- 高可用性：集群内的节点可以相互备份。
- 高拓展：可以方便地增加和减少节点来拓展或缩减集群容量。
- 数据均衡：通过分片技术，避免了单点写操作的瓶颈。

缺点：
- 实现复杂，需要了解和配置较多的参数。
- 节点间的通信和数据一致性问题需要特别关注。

##### Redis集群切片的几种常见方式

###### 哈希求余
- 借助哈希函数，把一个key映射到整数，根据**分片**数量**求余**，得到的余数即为数据要分配到的分片位置。
- 这个方法实现逻辑简单，分片数量越多，存储能力越高。但一旦集群需要扩容，存储的数据就可能发生变动，需要**重新分配**。


###### 一致性哈希算法
- 为了解决哈希求余算法因扩容可能导致的数据搬运问题，就有了一致性哈希算法。通过一致性哈希算法，将每个服务**节点**进行**哈希**运算，映射到**哈希环**上，再将数据键进行哈希运算，映射到哈希环上，之后一般通过**顺时针**查找到**最近的**节点进行存储。
- 每个节点负责一个片区的数据。
- 这个方法能够高效扩容，降低了数据搬运的成本，但在节点数量较少时可能存在**数据倾斜**问题。

###### 哈希槽分区算法
- 这为了解决一致性哈希算法在节点数量较少时可能发生的数据倾斜问题，引入了槽的概念，这是redis真正采用的分区算法。
- 算法是先定义一定的**槽**数量**分配给**分片**节点**，然后对**键**进行哈希算法，然后取算法结果的低16位，与**槽的数量**进行*模运算*，得到的**余数**就是这个key所属的槽。
- hash_slot=crc16(key)%16384，相当于16*1024或16k（用来计算hash值的算法）。将整个数据集划分为16384个哈希槽
- 每个分片节点负责一部分哈希槽的数据。虽然不是严格意义的均匀，但分片上的数据已经是比较均匀的了。

###### 总结
- 单独哈希怕变动
- 一致时针会倾斜
- 定好槽片再参与，求模分区较均匀。

### Redis的持久化

Redis是内存数据库，宕机会丢失数据，Redis重启后快速恢复数据，所以需要提供持久化机制。

Redis提供两种持久化方式：
- RDB（Redis Database）（默认开启）
- AOF（Append Only File）

#### RDB

RDB是Redis默认的存储方式，持久性是以指定的间隔将内存数据写入到磁盘中，生成一个快照文件。

触发快照的方式：
1. 符合自定义配置的快照规则。
2. 执行save或bgsave命令。
3. 执行flushall命令。
4. 执行主从复制操作（第一次）。

优点：
- RDB是二进制压缩文件，占用空间小，便于传输（传给Slave）；。
- 主进程fork子进程，可以最大化Redis性能。
- 使用RDB恢复数据比较快。

缺点：
- 不保证数据完整性，可能会丢失最后一次快照以后更改的所有数据。
- 父进程在执行fork子进程的操作指令时如果主进程过大会阻塞。

#### AOF

AOF在默认情况下是不开启的。开启后Redis将所有对数据库进行过**写入命令（及其参数）（RESP）记录到AOF文件**，以此达到记录数据库状态的目的。这样当Redis重启后只要按顺序回放这些命令就会恢复到原始状态了。

AOF会记录过程，RDB只管结果。

AOF原理：
- 命令传播。每当命令函数成功执行之后（主要是写命令），命令参数都会被传播到AOF程序中。
- 缓存追加。AOF程序根据收到的命令写入AOF缓存
- 文件写入和保存。AOF缓存内容别写到AOF文件末尾，如果设定的AOF保存条件被满足，将写入的内容真正保存到磁盘中。

AOF重写：
Redis可以在AOF体积变得过大时，自动在后台fork子进程对AOF进行重写。**重写后的新AOF文件包含了恢复当前数据库所需的最小命令集合**。AOF重写并不需要对原有的AOF文件进行任何写入和读取，它针对的是数据库中键的当前值。


#### 比较

|比较|RDB|AOF|
|-|-|-|
|数据文件大小|小，二进制压缩存储，存的是数据库某时刻的快照|大，文本存储（混合）|
|磁盘更新频率|更新频率较低，可配置，适合对数据实时要求不是很高的场景|有3种保存模式，默认每秒保存一次，更新频率高|
|数据安全|低，RDB配置会丢失最后一次快照之后的数据|高，AOF设置为每秒保存一次，则最多丢失2秒的数据|
|数据一致性|低，RDB每隔一段时间才进行快照，数据可能丢失或不一致|高，AOF记录了几乎所有的数据库更新命令|
|重启性能|快，只需加载最近的快照即可|慢，因为需要重放所有写命令|

#### 应用场景

- 内存数据库。使用rdb+aof混合存储，数据不容易丢。
- 缓存数据库。使用rdb性能高。
- 不建议只是用aof（性能差）。
- 数据还原时，采用rdb+aof配置的，会优先使用aof还原数据，因为aof文件比rdb更新频率高。只是用rdb时才只还原rdb。


### Redis的内存管理

为了更好的管理内存，Redis提供了一些管理方案，包括过期策略和内存淘汰。

#### 过期策略

对每个Key设置过期时间。Redis提供了Expire与ExpireAt两个命令设置过期时间，ExpireAt是设置过期时间戳，Expire是设置过期秒数。当到达过期时间后利用专门的过期策略对Key进行删除。

> 过期策略都是针对会**设置过期时间**的**key**。

##### 1.定期删除

类似一个守护线程，每间隔一段时间就执行一次（redis.conf的hz选项可配置），随机抽取一部分过期的key进行删除。

##### 2.惰性删除

因为定期删除随机抽取key进行删除，明显会遗漏很多过期key，因此还会有惰性删除。

惰性删除是当查询某个key时，判断该key是否已过期，过期则从缓存中删除，同时返回空。


#### 淘汰机制

无论**定期删除**还是**惰性删除**，都是一种不完全精准的删除策略，始终会存在已经过期的key还存在内存的场景。而且这2种过期策略都针对的是**设置了过期时间**的key，不适用于没有设置过期时间的key。

当Redis内存超出物理内存**上限**时，**内存**数据会开始和**磁盘**产生频繁的**数据交换**，交换会让Redis的性能急剧下降。所以Redis还提供了内存淘汰策略，用来筛选淘汰指定的key。

在redis.conf中，参数`maxmemory <bytes>`来设定最大内存（一般会将该参数设置为物理内存的四分之三），便会触发内存淘汰策略。

内存淘汰策略通过`maxmemory-policy`进行配置，目前redis提供了一下8种。

##### 8种淘汰机制
- `noeviction`
  - 默认淘汰策略。不会淘汰任何数据，当使用内存超过最大值时，再有写请求会返回错误。
- LRU：
  - `volatile-lru`
    - 有过期时间的key，淘汰**最近最少使用**的键，即删除使用的时间戳最远的；
    - 没有过期时间的key，不会进行淘汰，这样可以保证需要持久化的数据不会丢失。
  - `allkeys-lru`
    - 所有key，而不只是过期的key集合都会根据LRU算法进行淘汰。
- LFU：
  - `volatile-lfu`
    - 对设置了过期时间的key，淘汰一段时间内**使用频率最低**的键，即删除计数器最少的。
  - `allkeys-lfu`
    - 对所有key采取LFU算法进行删除。
- RANDOM:
  - `volatile-random`
    - 对所有设置了过期时间的key，随机淘汰。
  - `allkeys-random`
    - 所有key**随机**淘汰。
- TTL：
  - `volatile-ttl`
    - 对设置了过期时间的key，计算剩余寿命**ttl**值，ttl越小的优先被淘汰。
  
  
我们可以通过前缀将它们分为2类，volatile-与allkeys-，这两类策略的区别在于二者选择要删除的key时字典不同。

下面介绍下LRU与LFU。

##### LRU
LRU， Least Recently Used缩写，也就是最近很少使用。当内存不够时，每添加一条数据，都要抛弃一条最久时间没有使用的旧数据。

LRU是基于链表结构实现的，链表中的元素按操作顺序从前到后排列，最新操作的键会被移动到表头，当需要进行内存淘汰时，只需要删除链表尾部的元素即可。

Redis并没有使用标准的LRU实现方法，而是近似LRU的策略进行了优化，平衡了时间与空间的效率。*tips：一个key上一次的访问时间存储在redisObject的lru字段中。*

LRU在某些情况下仍然存在一些问题：假设有一个节点数据很久没有访问了，偶然间被访问了一次，lru字段被更新，那么在LRU策略下，这个节点会被保留。但显然这个key并不是我们想保留的数据，为了解决这一问题，便有了LFU。

##### LFU
LFU，Least Frequently Used缩写，即一段时间内最不常用的。它和key的使用次数有关。原理是：根据key最近被访问的频率进行淘汰，比较少访问的key优先淘汰。

相比LRU算法，LFU增加了访问频率这样的一个维度来统计数据的热点情况，LFU主要使用了两个双向链表去形成一个二维的双向链表，一个用来保存访问频率，另一个用来保存访问频率相同的所有元素，其内部按访问时间排序。

- 当添加元素的时候访问频次默认为1，于是找到相同频次的节点，然后添加到相同频率节点对应的双向链表的头部。
- 当元素被访问的时候就会增加对应的key访问频率，并且把访问的节点移动到下一个频次的节点。

LFU算法通过使用频率和上次访问时间来标记数据的热度，相比LRU算法，可以真正达到非热点数据的淘汰，但也因为增加了访问频率的维度，其实现的复杂度比LRU更高。


##### 淘汰策略的选择

- 如果数据呈现幂等性分布（即部分数据访问频率高，而其余部分访问频率较低），建议使用allkeys-lru或allkeys-lfu。
- 如果数据呈现平等分布（即所有数据访问概率大概相等），建议使用allkeys-random。
- 如果需要通过设置不同的ttl来确定数据过期的顺序，建议使用volatile-ttl。
- 如果你想让一些数据可以长期保存，而一些数据可以消除，建议使用volatile-lru或volatile-random。

由于设置expire会消耗额外的内存，如果你打算避免Redis内存浪费这一项上，可以选择allkeys-lru策略，这样就可以不再设置过期时间，搞笑利用内存。

#### 使用建议

虽然Redis提供了内存淘汰策略，但我们最好还是精简对Redis的使用，尽量不要淘汰内存数据。下面是一些使用建议：
- 不要放垃圾数据，及时清理无用数据。
- key尽量都设置过期时间。
  对具有时效性的key设置过期时间，通过redis自身的过期key清理策略来降低key对于内存的占用，同时也能够减少业务的麻烦，不需要定期手动清理了。
- 单key不要过大。
  这种key造成的网络传输延迟会比较大，需要分配的输出缓冲区也比较大，在定期清理的时候也容易造成比较高的延迟，最好能通过业务拆分、数据压缩等方式避免过大key产生。
- 不同的业务如果共用一个业务的话，最好使用不同的逻辑db分开。
  这是因为Redis的过期key清理策略和强制淘汰策略会遍历各个db。将key分布在不同db有助于过期key的及时清理。另外不同业务使用不同db有助于问题排查和无用数据的及时下线。


## Memcache与Redis的区别和联系

Memcache就是一个数据库，但是数据存储在内存中。常用来做缓存服务器，例如缓存数据库查询结果，缓存静态页等以减少数据库的访问。

memcache适合存储的数据有：

- 访问比较频繁，对安全性要求不高，丢失也无所谓的数据。
- 数据更新比较频繁的状态数据，比如用户的在线状态。
- memcache是以k-v形式存储，单个键值不能太大，不要超过1MB数据。

### Memcache与Redis能力比较

|能力|MemCache|Redis|
|-|-|-|
|数据类型|简单kv结构|多种数据结构（string/list/set/ZSet/hash）|
|持久化|不支持|支持|
|分布式存储|只能在客户端通过哈希分片/一致性哈希等分布式算法来实现分布式存储|有多种分布式方案，主从模式、哨兵模式、集群模式|
|多线程支持|支持|新版才支持|
|内存管理|有，私有内存池|无（2018年考题，存疑）|
|事务支持|不支持|有限|


## 数据库系统存储的比较

### 关系型数据库与文件系统存储比较

|比较|关系型数据库|文件系统|
|-|-|-|
|设计难度|结构设计需要符合关系模式，难度较大|针对特定应用系统设计，难度较小|
|数据冗余程度|遵守数据范式，数据冗余较少|以文件为维度，多个文件可能存在重复属性，数据冗余较大|
|数据架构|以数据库为中心组织、管理数据|以应用系统为中心组织、管理数据|
|应用拓展性|数据库独立于系统，容易在不同系统间共享数据|文件数据要符合特定应用系统要求，很难在不同的应用系统共享|

### 内存数据库与关系型数据库比较

|比较|内存数据库|关系型数据库|
|-|-|-|
|数据模型|键值对（key-value）|关系模式|
|读写性能|内存直接读写，性能高|依赖磁盘IO，性能较低|
|存储容量|基于机器内存大小存储，容量有限|基于磁盘存储，容量大|
|可靠性|依赖服务器运行和内存管理，恢复机制复杂，可靠性低|内建恢复机制，可靠性高|

--------
## 密码学

数据加解密是数据安全性的重要环节。

--------
## CRC16

CRC16， Cyclic Redundancy Check，是一种常用的循环冗余校验算法，用于检测和校验数据的完整性。

常用于**通信协议**、**数据存储**和**数据传输**等场景。

CRC16算法通过对数据进行一些列的位运算和异或操作来生成校验码，算法原理：
1. 初始化一个16位的寄存器为全1；
2. 将每个字节（8位）从高位到低位依次与寄存器进行异或操作；
3. 将每个字节进行循环左移8位，并重复步骤2；
4. 最终寄存器中的值即为生成的CRC16位校验码。



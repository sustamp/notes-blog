---
# layout: post
layout: post-custom
title: "拾遗补漏"
---

>**万时定律**，10000小时定律。  
简单来说，要成为某个领域顶尖的专业人才，需要10000小时持续不断的练习。例如小提琴、足球、国际象棋、围棋等领域，无一例外都遵循这个定律。  
技术人员的成长需要对技术的热情和持续不断学习，思考，实践和总结。

## 计算机基础
### 逻辑地址与物理地址的关系
在**十六进制/二进制**关系下：
- `逻辑地址` = `页号` + `页内地址`;
- `物理地址` = `物理块号` + `页内地址`;
- `页内地址`的位数通过`页面大小`转换成2的n次幂求解。
- `页号`为`逻辑地址`去掉`页内地址`的位数。

在**十进制**关系下:
- `逻辑地址` = `页号` * `页面大小` + `页内地址`;
- `物理地址` = `块号` * `页面大小` + `页内地址`;
- `页号` = `逻辑地址` / `页面大小` （*向下取整*）;
- `页内地址` = `逻辑地址` % `页面大小`（*取余*）;

> tips: 
> - 十进制（decimalism）。
> - 二进制（binary system），表示方法：101B。
> - 十六进制（Hexadecimal），表示方法如下：
>   - `0x` 前缀：这是c语言表示。比如： 0x1B1A。
>   - `H` 后缀：这是通常描述。比如： 1B1AH。


## 计算机网络
### 以太网帧长
在以太网标准中规定的帧长范围是 ***64*** 字节 ~ ***1500(+18)*** 字节。

以太网规定：
- **最小帧长**：64 字节。
- **最大帧长**：1500 (+18) 字节。

设置最小帧长的目的是为了避免冲突，最小帧长是根据**网络中检测冲突的最长时间**来定的。
- 要使CSMA/CD（载波多路复用/冲突检测）有效工作，数据帧要大于等于冲突检测需要的时间，所以：`最小帧长` = `冲突检测时间` * `数据传输速率`。

设置最大帧长目的是为了**避免某一主机长时间占用信道**。
- 信道是所有主机共享的，如果某主机发送的数据帧太长，就会长时间占据信道，影响其他主机通信。


### 无线网络技术覆盖范围
1. 802.15.1 蓝牙
   - 覆盖范围：10 m以内
2. 802.15.4 ZigBee
   - 覆盖范围： 10 ~ 100 m
3. 802.11n 无线局域网
   - 覆盖范围： 100 m 以内
4. 802.16n无线城域网
   - 覆盖范围： 2 ~ 10 km

## 系统工程
### 计算机性能评价指标
- 时钟频率（主频）。
- 运算速度。
- 运算精度。
- 数据处理速率(PDR, Processing Data Rate)。
- 吞吐率：单位时间内处理的作业数。

### 数据库性能评价指标
- 最大连接数
- 索引数量
- 最大并发事务处理能力


## 软件工程
### UML中的各种关系

![UML的关系示意图](https://sustamp.github.io/assets/pictures/UML-Relations.png)

参考资料：<a href="https://www.cnblogs.com/bruce1992/p/18008359" target="_blank">UML类图及各种线代表的关系含义总结</a>

### 多重度
软件工程UML中关联的多重度是指一个类的实例能够与另一个类的多少个实例相关联。
- `0..1`: 0个或1个
- `1`: 只能1个
- `3`: 只能3个
- `0..*` / `*`: 0个或多个
- `1..*`: 1个或多个
- `m..n`: m到n个

### 组合关系与聚合关系的区别
类与类之间存在的组合关系或聚合关系是有区别的。

组合关系：
- 类与类之间是**强关联**，在UML类图中是实心。
- 表示整体与部分的关系，但一旦整体对象不存在，部分对象也不存在。
- 例如：人由头部和身体组成，它们都不可分割。

聚合关系：
- 类与类之间是**弱关联**。在UML类图中是空心。
- 也表示整体与部分的关系，但成员对象可以脱离整体而独立存在。
- 例如：工人可以穿戴不同制式的工衣和工帽，工衣工帽也可以穿在视察领导身上，是可以独立存在的。

### 用例之间的关系
#### 包含关系
当可以从2个（含）以上的用例中提取**公共行为**时，应该使用包含关系。

- 例如：课程学习和课程考试都需要先检查学员的权限，`课程学习`与`检查权限`两个用例之间属于包含关系。

#### 拓展关系
如果**一个用例**明显地混合了2个（含）以上的不同场景，即根据情况**可能发生多种分支**，则可以将这个用例分为一个基本用例和一个或多个拓展用例，这样可以使描述更加清晰。

- 例如：课程学习过程中，如果所缴学费不够，就需要补缴学费，`课程学习`与`缴纳学费`两个用例之间属于拓展关系。

#### 泛化关系
当多个用例共同拥有一种**类似的结构和行为**的时候，可以将它们抽象成为**父用例**，其他用例作为泛化关系中的**子用例**。

泛化关系也就是继承关系，也称为“is-a-kind-of”关系，用于描述父类与子类之间的关系。

- 例如：课程学习前需要课程注册，可以采用电话注册或网络注册，`课程注册`与`网络注册`两个用例指甲属于泛化关系。

## 架构设计专业知识
### ERP系统
ERP，全称Enterprise Resource Planning，即企业资源规划，是在信息技术的基础上：
- 利用现代企业的先进管理思想，对企业的**物流**、**资金流**和**信息流**进行全面集成管理的管理信息系统。
- 为企业提供决策计划、控制和经营业绩评估的全方位和系统化的管理平台。

ERP系统主要包括：
1. 生产预测
2. 销售管理
3. 经营计划
4. 非生产计划
5. 物流需求计划
6. 能力需求计划
7. 车间作业计划
8. 采购与库存管理
9. 质量与设备管理
10. 财务管理
11. 有关拓展应用模块

### 电子政务
电子政务是对现有的政府形态的一种改造，利用信息技术和其他相关技术，将其管理和服务职能进行集成，在网络上实现政府组织结构和工作流程优化重组。

电子政务有3个行为主体：
- 政府
- 企(事)业单位
- 居民

电子政务主要有4个应用模式：
- G2G (Government To Government)：政府对政府
- G2E (Government To Employee)： 政府对公务员
- G2B (Government To Business)：政府对企业
- G2C (Government To Citizen)：政府对公民

### 信息安全
在信息安全领域，基本的安全性原则包括：
- **机密性(Confidentiality)**
  - 保护信息在使用、传输和存储时**不被泄露给未授权的用户**。
- **完整性(Integrity)**
  - 使用哈希校验是保证数据完整性的常用方法。
- **可用性(Availability)**
  - 保证合法用户对系统的正常访问，不会被不正当地拒绝。**DoS(拒绝服务攻击)**就是破坏系统的可用性。


破坏系统安全的一些常用攻击方式：
- 跨脚本攻击(XSS, Cross Site Scripting)
- 拒绝服务攻击(DoS, Denial Of Service)
- 跨站请求伪造攻击(CSRF, Cross Site Request Forgery)
- 缓冲区溢出攻击

XSS是指攻击者往页面插入恶意的HTML代码，当用户浏览该页时，嵌入Web中的html代码会被执行，从而实现劫持浏览器会话、强制弹出广告、网络钓鱼、删除网站内容、窃取用户Cookies资料、繁殖CSS蠕虫、实施DDoS攻击等目的。

DoS攻击利用大量合法的请求占用大量网络资源，以达到系统瘫痪的目的。收到DoS攻击的系统，可用性大大降低。

CSRF通过伪装来自受信用用户的身份（携带浏览器中的cookie信息），以其名义发送恶意请求（但对服务器来说是合法的请求），从而完成攻击者所期望的不法行为。比如发送邮件、转账、购买商品等。与XSS相比：
- XSS利用的是**用户对**指定**网站**的信任。
- CSRF利用的是**网站对**用户网页**浏览器**的信任。

> - CSRF-Token是防止CSRF攻击的常用方式，Token需要存储在服务器端。因它不再放在客户端Cookie中，攻击者无法获取并利用。  
> - Token可以放在服务器Session中，或服务器端具备分布式存储的数据库中，或使用JWT(Json Web Token)。
> - **验证码和密码**其实也可以起到CSRF-Token的作用，而且更安全。很多银行等网站会要求已经登录的用户在转账时再次输入密码。


缓冲区溢出攻击是指利用缓冲区溢出漏洞，从而控制主机进行攻击。

### 特定领域软件架构(DSSA)
DSSA(Domain-Specific Software Architecture)是在一个特定应用领域中，为一组应用提供组织结构参考的标准软件体系结构。

#### 特点
1. **特定领域**：DSSA 是专门为某个特定的应用领域设计的，例如医疗系统、金融系统、嵌入式系统等。
2. **标准化**：DSSA 提供了一套标准化的架构模式和组件，这些模式和组件已经在该领域中经过验证，可以有效地解决常见的问题。
3. **可复用性**：DSSA 通过复用已有的架构知识和模式，减少了重复设计的工作，提高了开发效率
4. **灵活性**(可拓展)：尽管 DSSA 提供了标准化的架构，但它仍然允许开发人员根据具体需求进行定制和扩展。

#### DSSA的三层模型
1. 领域开发环境
   - 这一层主要关注领域知识的获取和建模。包括：
     - 领域分析：识别领域中的关键概念、实体和关系。
     - 领域建模：将领域知识形式化为模型，例如领域模型、领域模式等。
     - 领域知识库：存储领域模型和模式，供后续开发使用。
2. 领域特定应用开发环境
   - 这一层主要关注具体应用的开发。开发人员在这个环境中使用领域知识库中的模型和模式，进行应用的设计和实现：
     - 应用设计：根据领域模型和模式，设计具体应用的架构和组件。
     - 应用实现：编写代码实现设计的架构和组件。
3. 应用执行环境
   - 这一层主要关注应用的部署和运行，包括：
     - 运行时环境：提供应用运行所需的基础设施，例如操作系统、数据库、网络等。
     - 中间件：提供应用所需的通用服务，例如消息队列、事务管理等。
     - 工具：提供开发、测试、部署等工具，帮助开发人员高效地完成工作。

> 思考：为啥第一层是**领域开发环境**而不是领域需求环境？  
> 理解：既然已经是**特定领域**了，说明需求在该领域是大致确定的，那么用领域开发环境来描述，更能体现特定的意义。

#### 应用工程师的角色
在 DSSA 中，**应用工程师**主要在领域特定应用开发环境中工作。他们使用领域知识库中的模型和模式，进行具体应用的设计和实现。应用工程师需要具备以下能力：
- 领域知识：了解特定领域的业务需求和技术背景。
- 设计能力：能够根据领域模型和模式，设计具体应用的架构和组件。
- 实现能力：能够编写代码实现设计的架构和组件。
- 测试能力：能够进行单元测试、集成测试等，确保应用的质量。

### 基于软件架构的设计(ABSD)
ABSD(Architecture Based Sofware Development)，强调由商业、质量和功能需求的组合驱动软件架构设计。
- 用`视角与视图`来描述**软件架构**。
- 用`用例与质量场景`来描述**需求**。

> 思考：在教程中学习到这一章节时得弄清`视角`、`视图`以及`质量场景`的不同概念和表现方式。


## 嵌入式基础
### 存取速度
存取速度从快到慢排列分别是：
- 寄存器组 > Cache > 内存 > Flash

> 理解：存储位置越靠近CPU的，速度越快。


### 软件低功耗设计
从以下几个方面展开：
- **软硬件协同设计**：即软件的设计要与硬件的匹配，考虑硬件因素。
- **编译优化**：采用低功耗优化的编译技术。
- **算法优化**：减少系统的持续运行时间，可从算法角度进行优化。
- 用**中断**代替查询。
- 进行**电源**的有效**管理**。



## 嵌入式软件的特点和实现方法

### 可剪裁性
在研发嵌入式产品过程中，产品的功能会不断的添加和更新，产品的型号也会越来越多。这时产品的软件研发团队就需要考虑是在*原有的软件版本上修改*还是*全新开发*。

从研发成本上考虑会考虑基于原有软件上修改。

原有软件上功能会越来越多，但一款产品可能只需要其中部分功能，这就要求嵌入式软件系统具有良好**可裁剪**性。

嵌入式系统提供良好的裁剪性，有利于产品开发团队做出更多差异化的产品和低成本的产品（裁剪后的软件系统通常也降低了对硬件的要求）。

通常在一个项目中不会只使用其中一种方法，而是会根据不同场景在不同的层次上同时使用。

#### 静态编译
静态编译主要是通过**条件编译**宏来控制。

为每个特性定义一个编译宏，当产品的特定确定后，在编译时只打开特定特性的编译开关，这样无关的代码就不会参与编译。

有效减少静态编译的软件包体积。

缺陷是必须重新编译代码，减低了代码的可维护性。

**静态编译**是嵌入式软件**可剪裁**性和**可配置**性的一种实现方法，包括对操作系统的剪裁（操作系统也是软件）。

#### 动态库
动态库会将各个功能模型分别编译成动态库，由主进程根据产品的功能需求加载需要的动态库。

优点是不用重新编译，缺陷是实现起来复杂。

动态库是嵌入式软件**可剪裁**性的一种实现方法。

#### 控制函数流程
控制函数流程实现起来类似**静态编译**，只不过是将静态编译时的编译宏改成全局变量判断。

这些全局变量应该在主进程启动时从规格文件获取特性并加载在全局变量中，通过这些特性全局变量控制函数（业务）流程，达到功能裁减的目的。

此方法是前面两种方法的折中，实现简单也不需要重新编译代码。但软件包体积没有减小。


### 可配置性
#### 数据驱动
数据驱动思想是认为**数据易变**，而**逻辑**相对比较**固定**，将数据和逻辑**分离**，使得数据易于修改和扩展。

以MP3播放器为例，使用**数据驱动**可以简化音乐播放器的设计。
- MP3播放器需要根据MP3文件进行音乐播放，不同的歌曲遵循相同的文件格式，播放器只需要根据文件格式进行统一的解析和处理。
- 当需要播放其他类型的音乐时，只需要添加相应的音乐文件和数据表，而不需要修改播放器本身的代码‌

数据驱动通过**定义数据表**控制程序的行为，这些数据表包含控制程序行为的各种参数和条件。

#### 配置表
配置表主要用于存储系统的配置参数，使得系统的行为可以根据不同的配置参数进行调整，从而提高软件的灵活性和可维护性。

配置表是一种数据结构，用于存储系统的各种配置参数。这些参数可以包括但不限于：
- 系统启动参数
- 设备驱动参数
- 通信协议参数
- 定时任务参数
- 用户界面设置
- 系统调试选项


### 高确定性
#### 静态分配资源
静态分配资源是指在系统启动时或编译时预先分配好所需的资源，而不是在运行时动态分配。

这种方法可以确保系统在运行过程中不会因为资源不足而导致不可预测的行为。

应用场景：
- 内存分配：在编译时或启动时**分配**固定的**内存块**，避免运行时的动态内存分配。
- 中断处理：预先**分配**中断处理**所需的资源**，确保中断处理的及时性和可靠性。
- 任务调度：预先**分配**任务所需的**CPU时间**和**内存**资源，确保任务按预定的时间表执行。

#### 状态机
状态机是一种数学模型，用于描述系统的**状态**及其**状态之间**的**转换**。

在嵌入式系统中，状态机常用于管理和控制系统的不同状态，确保系统在不同情况下能够按照预定的逻辑进行切换。


#### 静态任务调度
静态任务调度是指在系统启动时或编译时**预先确定**任务的**执行顺序**和**时间**，而不是在运行时动态调度。

这种方法可以确保任务在预定的时间内执行，提供高确定性的行为。

应用场景：
- 实时系统：确保关键任务在预定的时间内完成，满足实时性要求。
- 多任务系统：管理多个任务的执行顺序和时间，确保系统在多任务环境下的稳定运行。
- 周期性任务：管理周期性任务的执行，如定时采集传感器数据、定期发送心跳信号等。

#### 越界检查
越界检查的主要目的是防止数组、指针或其他**数据结构**类型**超出**其**合法范围**，从而避免潜在的系统崩溃、数据损坏或安全漏洞。

实现方法：
- 编译时检查。
  - 静态分析工具：使用静态分析工具在编译时检测潜在的越界访问。
  - 编译器选项：GCC 编译器的 -fbounds-check 选项可以在编译时插入边界检查代码。
- 运行时检查。
  - 手动检查：在代码中显式地添加边界检查逻辑。
  - 使用安全库：使用提供边界检查功能的库，如 C++ 标准库中的 std::vector，它在访问元素时会自动进行边界检查。
  - 硬件支持：一些嵌入式系统提供了硬件级别的边界检查功能，例如内存管理单元（MMU）可以检测和防止越界访问。

### 可靠性
#### 容错技术
容错技术是指系统在出现故障时仍然能够继续正常工作的能力。通过设计和实现容错技术，可以确保系统在部分组件或子系统失效的情况下，仍然能够完成预定的任务。

实现方法：
- 错误检测与纠正。
- 故障隔离。
  - 将系统划分为多个独立的模块，确保一个模块的故障不会影响其他模块的正常运行。
- 故障恢复。
  - 设计故障恢复机制，如重启模块、切换到备用系统、重试操作等，确保系统在故障发生后能够恢复正常运行。
- 冗余设计。
  - 通过增加冗余组件（如备用硬件、冗余软件模块）来提高系统的容错能力。

#### 余度技术
余度技术是指通过增加**冗余组件**或**路径**来提高系统的可靠性和可用性。

冗余可以是硬件冗余、软件冗余或信息冗余。

实现方法：
- 硬件冗余：增加备用的硬件组件，如双CPU系统、冗余电源、冗余存储设备等。
- 软件冗余：实现多个独立的软件模块或路径，确保在一个模块或路径失效时，其他模块或路径可以接管任务。
- 信息冗余：通过增加冗余信息（如校验码、备份数据）来提高数据的可靠性和完整性。

#### 鲁棒性设计
鲁棒性设计是指系统在面对不确定因素、异常输入或环境变化时，仍然能够保持稳定和可靠的能力。

鲁棒性设计的**目标**是使系统能够在各种**不利条件**下**正常工作**。

实现方法：
- 输入验证：对所有外部输入进行严格的验证，确保输入数据的有效性和合法性。
- 异常处理：设计健壮的异常处理机制，捕获并处理运行时可能出现的各种异常。
- 容错设计：结合容错技术和余度技术，提高系统的容错能力和可靠性。
- 环境适应性：在不同的环境条件下进行测试，确保系统在各种环境下都能正常工作。
- 资源管理：合理管理内存、CPU等资源，避免资源竞争和死锁。
- 性能优化：优化代码和算法，提高系统的响应速度和稳定性。
- 模块化设计：将系统划分为多个独立的模块，确保每个模块的功能单一且易于测试和维护。

### 安全性
#### 编码标准
#### 安全保障机制
#### FMECA

## 待研究的点

### 数据流图与系统流程图的区别

1. 并行性有区别。
   数据流图的处理过程**可并行**；流程图在某一时间点只能处理一个处理过程。
2. 展示目的不同。
   数据流图展示的是系统的**数据流**；流程图展示的是系统的**控制流**；
3. 计时标准不同。
   数据流图展示的是系统的全局处理过程，过程之间遵循不同的计时标准；流程图中处理过程遵循的是一致的计时标准。
4. 阶段不同。
   数据流图适用于**系统分析**中使用的逻辑建模阶段；流程图适用于**系统设计**中的物理建模阶段。

### 基于构件的软件开发方法及其应用

- 项目摘要
- 项目背景
- 技术分析
- 实施过程
- 结论与思考

#### 使用spring制作可依赖的jar包

之前使用过maven-archetype-quickstart构建了一个项目，编写了一些工具类方法并利用maven-assembly-plugin打包成了普通jar包，并可被其他系统引入。

而现在对maven-assembly-plugin的打包流程以及相关配置以及很模糊了，翻看之前的书签也没法重新梳理清楚。

其实本质就是想和现在spring开发通过maven引入jar包实现相关功能的一样。

那么是否有更简单的方法，或者重新理清楚maven-assembly-plugin的使用方式。

#### 现在的技术能力如何进行构建开发和实践

1.利用spring进行jar包开发。对独立性抢、常用性、耦合性低、业务清晰的功能进行单封装，并制作成可供依赖的jar包，提高代码复用率，缩短开发周期，减少开发成本，便于维护和管理。是否符合构件开发？

2.基于一个父项目下，划分多个子模块的工程是否也符合构件开发？

3.有什么其他比较容易理解或符合认知的构件项目？


## 布隆过滤器
### 目的
解决当需要存储大量数据时，如何以最少的内存判断某个元素**是否存在于集合中**。

### 设计理念
**尽可能节省空间的情况下快速判断元素是否存在**，即使这意味着引入一定的误报风险。

### 应用场景
布隆过滤器设计的场景更倾向于**优化查询效率**和**节省存储空间**。允许某个元素“可能存在”而不是“完全存在”，就能大幅节约存储空间，尤其适用于对查询正确性要求不苛刻的场景。

布隆过滤器应用于缓存系统、垃圾邮件过滤、网页URL去重、集合重复元素判别、查询加速等多个场景。

### 基本原理
布隆过滤器的核心思想可以简化为**位数组**和**多个哈希函数**的结合。

1. 位数组  
   布隆过滤器使用一个长度为 m 的位数组，每一位都初始化为 0。这些位将用于表示元素的存在情况。

2. 多个哈希函数  
   布隆过滤器配备了 k 个独立的哈希函数。每个哈希函数都会为输入的元素生成一个 0 到 m-1 之间的索引值，也就是将元素“映射”到位数组中的某个位置。  
   通过多个哈希函数，**一个元素**会影响位数组中的**多个位置**，从而**降低哈希冲突**的风险。

3. 添加元素  
   当添加一个元素到布隆过滤器时，k个哈希函数会为该元素生成k个不同的索引值，并在位数组中将k个位置设置为1。
   
4. 查询元素  
   查询元素是否存在时，k个哈希函数会生成该元素的k个位置，并检查位数组中这个k个位置是否都为1。如果都为1，则表示元素**可能存在**；如果有任何一个位置为0，则确定元素不存在。

5. 误报率  
   布隆过滤器的一个关键特性是**可能误报**。因为位数组大小是有限的，多个元素可能会被不同的哈希函数映射到相同的位置上，导致某些不在集合的元素被误认为存在。  
   误报率与位数组的长度m，哈希函数的数量K，以及集合中的元素n有关。合理选择这些参数，可以在误报率和存储效率间做出权衡。

### 优缺点
优点：
1. 查询速度快。
   - 只需检查元素被映射在位数组中的几个位置即可。
2. 高效节省存储空间。  
   - 布隆过滤器并不存储元素本身，使用位数组占位，使用的存储空间更少。
3. 不漏报。  
   - 如果某个元素不在集合中，就一定不存在。

缺点：
1. 有一定的误报率。
   - 可能会错误地判断某个不在集合中的元素存在。
2. 不可删除（删除困难）。
   - 因为位数组的位可能被多个元素**共用**，因为误报的特性，布隆过滤器无法保证删除的元素的确存在于集合中。

### 总结
- **以小博大**查询快  
  - 使用少量的存储空间，来获得对大量数据进行快速查询的效率。
- **分而治之**冲突小  
  - 使用多个不同的哈希元素对元素处理，生成不同的索引位置，降低哈希冲突。
- **位理万机**可误报不删除  
  - 多个元素可能被映射到同一个位置，从而出现误报，也正因此，一般不删除布隆过滤器中的元素。

资料引用：
<a href="https://zhuanlan.zhihu.com/p/720288602" target="_blank">https://zhuanlan.zhihu.com/p/720288602</a>

--------
## 缓存穿透、缓存击穿、缓存雪崩

### 1.缓存穿透
缓存穿透是指要查询的**key不在**缓存中，或**key不在**缓存**也不在数据库**中，导致大量的请求直接压到数据库中的情况。

解决方案：
1. 缓存空对象，即缓存null。
   这个方案存在2个问题：
   - 不存在的key理论上是无限的，这会导致内存占用过多，缓存性能下降。
   - 若数据库突然写入这类key的数据并未更新到缓存时，会导致缓存期间数据不一致。
2. 使用布隆过滤器等方式，对key值进行过滤，仅允许系统存在的key进行后续操作。
   
### 2.缓存击穿
缓存击穿是指缓存中的**热点数据**key过期，在过期的瞬间会有大量的请求（高并发）过来直接访问数据库，导致数据库压力增加。

解决方案：
1. 缓存预热：在程序启动时或高峰期时间通过定时任务提前将热点数据更新到缓存中，避免高峰期间的大量请求访问到数据库。
2. 加锁控制：利用分布式锁使得同一时间只有一个请求能访问到数据库并更新缓存，这样其他请求线程只能等待锁释放，得到锁之后已经可以读取到缓存中的数据
3. 设置数据永不过期：根据业务上的常用数据，可以酌情设置数据永不过期。
   
### 3.缓存雪崩
缓存雪崩是指缓存中大量key在**同一时间过期**，从而导致大量请求访问到数据库中，数据库随时可能宕机的现象。

解决方案：
1. 设置不同过期时间：给不同的key设置不同的过期时间，使失效时间尽量**分散**，避免同一时间过期。
2. 加锁或排队：缓存失效后，通过排它锁或队列的方式控制数据库写缓存的线程数量，使得操作串行化。
3. 多级缓存方案：酌情设置多级缓存。使得过期key可以从二级或多级缓存中读取到数据。
4. 限流措施：使用令牌桶等限流算法控制请求数量，减少服务压力。

### 总结
- 过滤防穿透。
- 预热防击穿。
- 雪崩要排队、分散限流降风险。


--------
## Redis

Redis是一个高性能的键值存储，它支持多重丰富的数据结构。每种结构都有其特定的用途和底层实现。

### Redis支持的八种数据类型

表格举例Redis常用的数据类型与业务功能对照：

|数据类型|存储的值|可实现的业务功能|
|--|--|--|
|String|字符串、整型或浮点数|用户帖子的评论计数器|
|List|列表|支持粉丝列表功能；每个用户的发布/订阅列表可以表示为一个列表|
|Set|无序集合|每个用户的好友可以表示为一个集合（共同好友功能）；每个帖子的标签也可以表示为一个集合|
|Hash|包括键值对的无序散列表|用户信息的结构化存储|
|ZSset|有序集合|排行榜功能|


#### 1.字符串（String）

文本、数字、二进制数据等。它在Redis内部以动态字符串（SDS，Simple Dynamic String）的形式存储，以节省内存。

#### 2.哈希（Hash）

hash是键值对的集合，适合表示**对象**的属性。最常用的是存储对象。内部实现主要有2种：

- 压缩列表（ziplist）：当哈希数量较少且每个键值对的长度较短时使用。
- 哈希表（hashtable）：当哈希数量增多或其中某个键或值变长后，自动转为哈希表。

#### 3.列表（List）

列表是一组有序的字符串，可以从列表的头部或尾部添加或删除元素。内部实现有2种：

- 压缩列表（ziplist）：元素数据量较少且每个元素较短时使用
- 双向链表（LinkedList）：元素数量较多时，会自动转为双向链表。

#### 4.集合（Set）

集合是无序且唯一的字符串集合。内部采用哈希表（hashtable）实现。哈希表的键是集合的值，值是null。

#### 5.有序集合（ZSet / Sorted Set）

有序集合类似Set，但每个元素都会关联一个分数（Score），元素按分数排序。内部使用一种结构：跳表和哈希表。

- 跳表（skiplist）：快速实现范围查询和排序
- 哈希表（hashtable）：快速定位元素

#### 6.位图（BitMap）

位图将字符串值视为一个位数组，可以进行位操作。内部存储采用字符串，最大长度可达512MB。

- 字节数组（byte array）：实际存储位图数据的结构，是一个连续的内存区域。

#### 7.HyperLogLog

HyperLogLog是基数估算数据结构，用于估算不重复元素的数量。利用概率算法实现，误差率约0.81%。用于大规模数据去重计数。

- 稀疏矩阵（Sparse Representation）：当元素少时，用压缩方法存储。
- 密集矩阵（Dense Representation）：当元素多到一定程度时，转为密集表示。


#### 8.地理空间（Geospatial）

Redis的地理空间拓展允许存储地理坐标，并提供地理范围查询、距离计算等功能。内部试用有序集合（Sorted Set）数据类型实现，利用GeoHash编码。

- GeoHash编码：将经纬度编码为字符串，保证地理位置靠近的两个编码也是靠近的。
- 跳表（skiplist）和哈希表（hashtable）：与有序集合共享的实现，支持半径查询和排序。

### Redis的分布式架构

#### 主从模式

Master-Slave模式是最简单的一种分布式架构。有一个主节点和一个或以上的从节点。

原理：
- 主节点：负责处理写操作（写入、更新、删除）
- 从节点：负责处理读操作，同时从主节点同步数据，保证数据一致性。

优点：
- **读写分离**，提高读性能，减少写节点的压力。
- 主节点故障时，从节点可以升级为主节点，保证服务的高可用性。

缺点：
- **单点故障**：如果**主节点**挂了，需要手动切换从节点为主节点。
- **写**操作压力**集中**在主节点，拓展性有限。

#### 哨兵模式

Sentinel模式是主从模式的扩展，通过监控主/从节点的状态，自动将从节点升级为主节点，保证服务的高可用性。在主从模式的基础上增加了**监控**和自动**故障转移**功能。

原理:
- 哨兵节点：独立于主/从节点的监控进程，负责监控主/从节点的状态。
- 当主节点故障时，哨兵节点会自动选举一个从节点作为新的主节点，并通知客户端更新连接信息。

优点：
- 自动故障转移，减少人为干预。
- 提高系统的高可用性和稳定性。

缺点：
- 哨兵节点自身也可能有**单点故障**，需要配置多个哨兵节点互相监控。
- 实现相对复杂，需要额外的配置和维护。
  
**总结**
- 一主多从，读写分离又分工。主从切换要手动，哨兵监控来捉刀。
- 哨兵额外需配置，又怕单点出问题。
- 并发高又数据大，集群分片用哈希。

#### 集群模式

Cluster是Redis提供的一种更复杂、更强大的分布式解决方案，适用于大规模数据和高并发场景。

原理：
- 数据分片（Sharding）：将数据分布到多个节点上，每个节点只存储一部分数据。
- 每个节点既可以是主节点也可以有对应的从节点，形成一个集群。

优点：
- 高可用性：集群内的节点可以相互备份。
- 高拓展：可以方便地增加和减少节点来拓展或缩减集群容量。
- 数据均衡：通过分片技术，避免了单点写操作的瓶颈。

缺点：
- 实现复杂，需要了解和配置较多的参数。
- 节点间的通信和数据一致性问题需要特别关注。

##### Redis集群切片的几种常见方式

###### 哈希求余
- 借助哈希函数，把一个key映射到整数，根据**分片**数量**求余**，得到的余数即为数据要分配到的分片位置。
- 这个方法实现逻辑简单，分片数量越多，存储能力越高。但一旦集群需要扩容，存储的数据就可能发生变动，需要**重新分配**。


###### 一致性哈希算法
- 为了解决哈希求余算法因扩容可能导致的数据搬运问题，就有了一致性哈希算法。通过一致性哈希算法，将每个服务**节点**进行**哈希**运算，映射到**哈希环**上，再将数据键进行哈希运算，映射到哈希环上，之后一般通过**顺时针**查找到**最近的**节点进行存储。
- 每个节点负责一个片区的数据。
- 这个方法能够高效扩容，降低了数据搬运的成本，但在节点数量较少时可能存在**数据倾斜**问题。

###### 哈希槽分区算法
- 这为了解决一致性哈希算法在节点数量较少时可能发生的数据倾斜问题，引入了槽的概念，这是redis真正采用的分区算法。
- 算法是先定义一定的**槽**数量**分配给**分片**节点**，然后对**键**进行哈希算法，然后取算法结果的低16位，与**槽的数量**进行*模运算*，得到的**余数**就是这个key所属的槽。
- hash_slot=crc16(key)%16384，相当于16*1024或16k（用来计算hash值的算法）。将整个数据集划分为16384个哈希槽
- 每个分片节点负责一部分哈希槽的数据。虽然不是严格意义的均匀，但分片上的数据已经是比较均匀的了。

###### 总结
- 单独哈希怕变动
- 一致时针会倾斜
- 定好槽片再参与，求模分区较均匀。

### Redis分布式锁及优缺点


### Redis的持久化

Redis是内存数据库，宕机会丢失数据，Redis重启后快速恢复数据，所以需要提供持久化机制。

Redis提供两种持久化方式：
- RDB（Redis Database）（默认开启）
- AOF（Append Only File）

#### RDB

RDB是Redis默认的存储方式，持久性是以指定的间隔将内存数据写入到磁盘中，生成一个快照文件。

触发快照的方式：
1. 符合自定义配置的快照规则。
2. 执行save或bgsave命令。
3. 执行flushall命令。
4. 执行主从复制操作（第一次）。

优点：
- RDB是二进制压缩文件，占用空间小，便于传输（传给Slave）；。
- 主进程fork子进程，可以最大化Redis性能。
- 使用RDB恢复数据比较快。

缺点：
- 不保证数据完整性，可能会丢失最后一次快照以后更改的所有数据。
- 父进程在执行fork子进程的操作指令时如果主进程过大会阻塞。

#### AOF

AOF在默认情况下是不开启的。开启后Redis将所有对数据库进行过**写入命令（及其参数）（RESP）记录到AOF文件**，以此达到记录数据库状态的目的。这样当Redis重启后只要按顺序回放这些命令就会恢复到原始状态了。

AOF会记录过程，RDB只管结果。

AOF原理：
- 命令传播。每当命令函数成功执行之后（主要是写命令），命令参数都会被传播到AOF程序中。
- 缓存追加。AOF程序根据收到的命令写入AOF缓存
- 文件写入和保存。AOF缓存内容别写到AOF文件末尾，如果设定的AOF保存条件被满足，将写入的内容真正保存到磁盘中。

AOF重写：
Redis可以在AOF体积变得过大时，自动在后台fork子进程对AOF进行重写。**重写后的新AOF文件包含了恢复当前数据库所需的最小命令集合**。AOF重写并不需要对原有的AOF文件进行任何写入和读取，它针对的是数据库中键的当前值。


#### 比较

|比较|RDB|AOF|
|-|-|-|
|数据文件大小|小，二进制压缩存储，存的是数据库某时刻的快照|大，文本存储（混合）|
|磁盘更新频率|更新频率较低，可配置，适合对数据实时要求不是很高的场景|有3种保存模式，默认每秒保存一次，更新频率高|
|数据安全|低，RDB配置会丢失最后一次快照之后的数据|高，AOF设置为每秒保存一次，则最多丢失2秒的数据|
|数据一致性|低，RDB每隔一段时间才进行快照，数据可能丢失或不一致|高，AOF记录了几乎所有的数据库更新命令|
|重启性能|快，只需加载最近的快照即可|慢，因为需要重放所有写命令|

#### 应用场景

- 内存数据库。使用rdb+aof混合存储，数据不容易丢。
- 缓存数据库。使用rdb性能高。
- 不建议只是用aof（性能差）。
- 数据还原时，采用rdb+aof配置的，会优先使用aof还原数据，因为aof文件比rdb更新频率高。只是用rdb时才只还原rdb。


### Redis的内存管理

为了更好的管理内存，Redis提供了一些管理方案，包括过期策略和内存淘汰。

#### 过期策略

对每个Key设置过期时间。Redis提供了Expire与ExpireAt两个命令设置过期时间，ExpireAt是设置过期时间戳，Expire是设置过期秒数。当到达过期时间后利用专门的过期策略对Key进行删除。

> 过期策略都是针对会**设置过期时间**的**key**。

##### 1.定期删除

类似一个守护线程，每间隔一段时间就执行一次（redis.conf的hz选项可配置），随机抽取一部分过期的key进行删除。

##### 2.惰性删除

因为定期删除随机抽取key进行删除，明显会遗漏很多过期key，因此还会有惰性删除。

惰性删除是当查询某个key时，判断该key是否已过期，过期则从缓存中删除，同时返回空。


#### 淘汰机制

无论**定期删除**还是**惰性删除**，都是一种不完全精准的删除策略，始终会存在已经过期的key还存在内存的场景。而且这2种过期策略都针对的是**设置了过期时间**的key，不适用于没有设置过期时间的key。

当Redis内存超出物理内存**上限**时，**内存**数据会开始和**磁盘**产生频繁的**数据交换**，交换会让Redis的性能急剧下降。所以Redis还提供了内存淘汰策略，用来筛选淘汰指定的key。

在redis.conf中，参数`maxmemory <bytes>`来设定最大内存（一般会将该参数设置为物理内存的四分之三），便会触发内存淘汰策略。

内存淘汰策略通过`maxmemory-policy`进行配置，目前redis提供了一下8种。

##### 8种淘汰机制
- `noeviction`
  - 默认淘汰策略。不会淘汰任何数据，当使用内存超过最大值时，再有写请求会返回错误。
- LRU：
  - `volatile-lru`
    - 有过期时间的key，淘汰**最近最少使用**的键，即删除使用的时间戳最远的；
    - 没有过期时间的key，不会进行淘汰，这样可以保证需要持久化的数据不会丢失。
  - `allkeys-lru`
    - 所有key，而不只是过期的key集合都会根据LRU算法进行淘汰。
- LFU：
  - `volatile-lfu`
    - 对设置了过期时间的key，淘汰一段时间内**使用频率最低**的键，即删除计数器最少的。
  - `allkeys-lfu`
    - 对所有key采取LFU算法进行删除。
- RANDOM:
  - `volatile-random`
    - 对所有设置了过期时间的key，随机淘汰。
  - `allkeys-random`
    - 所有key**随机**淘汰。
- TTL：
  - `volatile-ttl`
    - 对设置了过期时间的key，计算剩余寿命**ttl**值，ttl越小的优先被淘汰。
  
  
`volatile-`与`allkeys-`，这两类前缀不同的策略的区别在于二者选择要删除的key时字典不同。

下面介绍下LRU与LFU。

##### LRU
LRU， Least Recently Used缩写，也就是最近很少使用。当内存不够时，每添加一条数据，都要抛弃一条最久时间没有使用的旧数据。

LRU是基于链表结构实现的，链表中的元素按操作顺序从前到后排列，最新操作的键会被移动到表头，当需要进行内存淘汰时，只需要删除链表尾部的元素即可。

Redis并没有使用标准的LRU实现方法，而是近似LRU的策略进行了优化，平衡了时间与空间的效率。*tips：一个key上一次的访问时间存储在redisObject的lru字段中。*

LRU在某些情况下仍然存在一些问题：假设有一个节点数据很久没有访问了，偶然间被访问了一次，lru字段被更新，那么在LRU策略下，这个节点会被保留。但显然这个key并不是我们想保留的数据，为了解决这一问题，便有了LFU。

##### LFU
LFU，Least Frequently Used缩写，即一段时间内最不常用的。它和key的使用次数有关。原理是：根据key最近被访问的频率进行淘汰，比较少访问的key优先淘汰。

相比LRU算法，LFU增加了访问频率这样的一个维度来统计数据的热点情况，LFU主要使用了两个双向链表去形成一个二维的双向链表，一个用来保存访问频率，另一个用来保存访问频率相同的所有元素，其内部按访问时间排序。

- 当添加元素的时候访问频次默认为1，于是找到相同频次的节点，然后添加到相同频率节点对应的双向链表的头部。
- 当元素被访问的时候就会增加对应的key访问频率，并且把访问的节点移动到下一个频次的节点。

LFU算法通过使用频率和上次访问时间来标记数据的热度，相比LRU算法，可以真正达到非热点数据的淘汰，但也因为增加了访问频率的维度，其实现的复杂度比LRU更高。


##### 淘汰策略的选择

- 如果数据呈现幂等性分布（即部分数据访问频率高，而其余部分访问频率较低），建议使用allkeys-lru或allkeys-lfu。
- 如果数据呈现平等分布（即所有数据访问概率大概相等），建议使用allkeys-random。
- 如果需要通过设置不同的ttl来确定数据过期的顺序，建议使用volatile-ttl。
- 如果你想让一些数据可以长期保存，而一些数据可以消除，建议使用volatile-lru或volatile-random。

由于设置expire会消耗额外的内存，如果你打算避免Redis内存浪费这一项上，可以选择allkeys-lru策略，这样就可以不再设置过期时间，搞笑利用内存。

#### 使用建议

虽然Redis提供了内存淘汰策略，但我们最好还是精简对Redis的使用，尽量不要淘汰内存数据。下面是一些使用建议：
- 不要放垃圾数据，及时清理无用数据。
- key尽量都设置过期时间。
  对具有时效性的key设置过期时间，通过redis自身的过期key清理策略来降低key对于内存的占用，同时也能够减少业务的麻烦，不需要定期手动清理了。
- 单key不要过大。
  这种key造成的网络传输延迟会比较大，需要分配的输出缓冲区也比较大，在定期清理的时候也容易造成比较高的延迟，最好能通过业务拆分、数据压缩等方式避免过大key产生。
- 不同的业务如果共用一个业务的话，最好使用不同的逻辑db分开。
  这是因为Redis的过期key清理策略和强制淘汰策略会遍历各个db。将key分布在不同db有助于过期key的及时清理。另外不同业务使用不同db有助于问题排查和无用数据的及时下线。


## Memcache与Redis的区别和联系

Memcache就是一个数据库，但是数据存储在内存中。常用来做缓存服务器，例如缓存数据库查询结果，缓存静态页等以减少数据库的访问。

memcache适合存储的数据有：

- 访问比较频繁，对安全性要求不高，丢失也无所谓的数据。
- 数据更新比较频繁的状态数据，比如用户的在线状态。
- memcache是以k-v形式存储，单个键值不能太大，不要超过1MB数据。

### Memcache与Redis能力比较

|能力|MemCache|Redis|
|-|-|-|
|数据类型|简单kv结构|多种数据结构（string/list/set/ZSet/hash）|
|持久化|不支持|支持|
|分布式存储|只能在客户端通过哈希分片/一致性哈希等分布式算法来实现分布式存储|有多种分布式方案，主从模式、哨兵模式、集群模式|
|多线程支持|支持|新版才支持|
|内存管理|有，私有内存池|无（2018年考题，存疑）|
|事务支持|不支持|有限|


## 数据库系统存储的比较

### 关系型数据库与文件系统存储比较

|比较|关系型数据库|文件系统|
|-|-|-|
|设计难度|结构设计需要符合关系模式，难度较大|针对特定应用系统设计，难度较小|
|数据冗余程度|遵守数据范式，数据冗余较少|以文件为维度，多个文件可能存在重复属性，数据冗余较大|
|数据架构|以数据库为中心组织、管理数据|以应用系统为中心组织、管理数据|
|应用拓展性|数据库独立于系统，容易在不同系统间共享数据|文件数据要符合特定应用系统要求，很难在不同的应用系统共享|

### 内存数据库与关系型数据库比较

|比较|内存数据库|关系型数据库|
|-|-|-|
|数据模型|键值对（key-value）|关系模式|
|读写性能|内存直接读写，性能高|依赖磁盘IO，性能较低|
|存储容量|基于机器内存大小存储，容量有限|基于磁盘存储，容量大|
|可靠性|依赖服务器运行和内存管理，恢复机制复杂，可靠性低|内建恢复机制，可靠性高|

--------
## 密码学

数据加解密是数据安全性的重要环节。

--------
## CRC16

CRC16， Cyclic Redundancy Check，是一种常用的循环冗余校验算法，用于检测和校验数据的完整性。

常用于**通信协议**、**数据存储**和**数据传输**等场景。

CRC16算法通过对数据进行一些列的位运算和异或操作来生成校验码，算法原理：
1. 初始化一个16位的寄存器为全1；
2. 将每个字节（8位）从高位到低位依次与寄存器进行异或操作；
3. 将每个字节进行循环左移8位，并重复步骤2；
4. 最终寄存器中的值即为生成的CRC16位校验码。


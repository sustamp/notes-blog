---
# layout: post
layout: post-custom
title: "拾遗补漏"
---

>**万时定律**，10000小时定律。  
简单来说，要成为某个领域顶尖的专业人才，需要10000小时持续不断的练习。例如小提琴、足球、国际象棋、围棋等领域，无一例外都遵循这个定律。  
技术人员的成长需要对技术的热情和持续不断学习，思考，实践和总结。

本文目录：
- [待研究的点](#待研究的点)
  - [数据流图与系统流程图的区别](#数据流图与系统流程图的区别)
  - [基于构件的软件开发方法及其应用](#基于构件的软件开发方法及其应用)
    - [使用spring制作可依赖的jar包](#使用spring制作可依赖的jar包)
    - [现在的技术能力如何进行构建开发和实践](#现在的技术能力如何进行构建开发和实践)
- [SOLID设计原则](#solid设计原则)
  - [Single responsiblity principle（单一职责原则）](#single-responsiblity-principle单一职责原则)
  - [Open-Closed principle（开闭原则）](#open-closed-principle开闭原则)
  - [Liskov substitution principle（里氏替换原则）](#liskov-substitution-principle里氏替换原则)
  - [Inteface segregation principle（接口隔离原则）](#inteface-segregation-principle接口隔离原则)
  - [Dependency inversion principle（依赖倒置原则）](#dependency-inversion-principle依赖倒置原则)
- [布隆过滤器](#布隆过滤器)
  - [目的](#目的)
  - [设计理念](#设计理念)
  - [应用场景](#应用场景)
  - [基本原理](#基本原理)
  - [优缺点](#优缺点)
  - [总结](#总结)
- [缓存穿透、缓存击穿、缓存雪崩](#缓存穿透缓存击穿缓存雪崩)
  - [1.缓存穿透](#1缓存穿透)
  - [2.缓存击穿](#2缓存击穿)
  - [3.缓存雪崩](#3缓存雪崩)
  - [总结](#总结-1)
- [数据库设计的规范化和反规范化](#数据库设计的规范化和反规范化)
  - [一、一些基本术语](#一一些基本术语)
  - [二、关系模式](#二关系模式)
    - [2.1 什么是关系模式](#21-什么是关系模式)
  - [三、数据依赖](#三数据依赖)
    - [3.1 函数依赖](#31-函数依赖)
      - [3.1.1 完全函数依赖](#311-完全函数依赖)
      - [3.1.2 部分函数依赖](#312-部分函数依赖)
      - [3.1.3 传递函数依赖](#313-传递函数依赖)
    - [3.2 多值依赖](#32-多值依赖)
    - [3.3 连接依赖](#33-连接依赖)
  - [四、规范化](#四规范化)
    - [4.1 第一范式（1NF）](#41-第一范式1nf)
    - [4.2 第二范式（2NF）](#42-第二范式2nf)
    - [4.3 第三范式（3NF）](#43-第三范式3nf)
    - [4.4 巴斯-科德范式（BCNF）](#44-巴斯-科德范式bcnf)
    - [4.5 第四范式（4NF）](#45-第四范式4nf)
    - [4.6 第五范式（5NF）](#46-第五范式5nf)
    - [总结](#总结-2)
  - [五、反规范化](#五反规范化)
    - [5.1 冗余列](#51-冗余列)
    - [5.2 派生列](#52-派生列)
    - [5.3 表重组](#53-表重组)
    - [5.4 表分割](#54-表分割)
      - [5.4.1 水平分割](#541-水平分割)
      - [5.4.2 垂直分割](#542-垂直分割)
- [Redis](#redis)
  - [Redis支持的八种数据类型](#redis支持的八种数据类型)
    - [1.字符串（String）](#1字符串string)
    - [2.哈希（Hash）](#2哈希hash)
    - [3.列表（List）](#3列表list)
    - [4.集合（Set）](#4集合set)
    - [5.有序集合（ZSet / Sorted Set）](#5有序集合zset--sorted-set)
    - [6.位图（BitMap）](#6位图bitmap)
    - [7.HyperLogLog](#7hyperloglog)
    - [8.地理空间（Geospatial）](#8地理空间geospatial)
  - [Redis的分布式架构](#redis的分布式架构)
    - [主从模式](#主从模式)
    - [哨兵模式](#哨兵模式)
    - [集群模式](#集群模式)
      - [Redis集群切片的几种常见方式](#redis集群切片的几种常见方式)
  - [Redis的持久化](#redis的持久化)
    - [RDB](#rdb)
    - [AOF](#aof)
    - [比较](#比较)
    - [应用场景](#应用场景-1)
  - [Redis的内存管理](#redis的内存管理)
    - [过期策略](#过期策略)
      - [1.定期删除](#1定期删除)
      - [2.惰性删除](#2惰性删除)
    - [淘汰机制](#淘汰机制)
      - [LRU](#lru)
      - [LFU](#lfu)
      - [淘汰策略的选择](#淘汰策略的选择)
    - [使用建议](#使用建议)
- [Memcache与Redis的区别和联系](#memcache与redis的区别和联系)
  - [Memcache与Redis能力比较](#memcache与redis能力比较)
- [数据库系统存储的比较](#数据库系统存储的比较)
  - [关系型数据库与文件系统存储比较](#关系型数据库与文件系统存储比较)
  - [内存数据库与关系型数据库比较](#内存数据库与关系型数据库比较)
- [密码学](#密码学)
- [CRC16](#crc16)

--------
## 待研究的点

### 数据流图与系统流程图的区别

1. 并行性有区别。
   数据流图的处理过程**可并行**；流程图在某一时间点只能处理一个处理过程。
2. 展示目的不同。
   数据流图展示的是系统的**数据流**；流程图展示的是系统的**控制流**；
3. 计时标准不同。
   数据流图展示的是系统的全局处理过程，过程之间遵循不同的计时标准；流程图中处理过程遵循的是一致的计时标准。
4. 阶段不同。
   数据流图适用于**系统分析**中使用的逻辑建模阶段；流程图适用于**系统设计**中的物理建模阶段。

### 基于构件的软件开发方法及其应用

- 项目摘要
- 项目背景
- 技术分析
- 实施过程
- 结论与思考

#### 使用spring制作可依赖的jar包

之前使用过maven-archetype-quickstart构建了一个项目，编写了一些工具类方法并利用maven-assembly-plugin打包成了普通jar包，并可被其他系统引入。

而现在对maven-assembly-plugin的打包流程以及相关配置以及很模糊了，翻看之前的书签也没法重新梳理清楚。

其实本质就是想和现在spring开发通过maven引入jar包实现相关功能的一样。

那么是否有更简单的方法，或者重新理清楚maven-assembly-plugin的使用方式。

#### 现在的技术能力如何进行构建开发和实践

1.利用spring进行jar包开发。对独立性抢、常用性、耦合性低、业务清晰的功能进行单封装，并制作成可供依赖的jar包，提高代码复用率，缩短开发周期，减少开发成本，便于维护和管理。是否符合构件开发？

2.基于一个父项目下，划分多个子模块的工程是否也符合构件开发？

3.有什么其他比较容易理解或符合认知的构件项目？

--------
## SOLID设计原则

### Single responsiblity principle（单一职责原则）
一个类或模块只负责一个职责或功能。

### Open-Closed principle（开闭原则）
对模块、类、方法拓展开放，对修改关闭。

### Liskov substitution principle（里氏替换原则）
子类能够替换父类对象出现的任何地方，并且保证原来程序的逻辑行为不变。

### Inteface segregation principle（接口隔离原则）
为各个类建立它们需要的专门接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。例如UserService接口有登录、查询、注册等一些列方法，而删除操作是慎重的，且可能是特定系统才拥有的功能，所以可以专门定义一个RestrictedUserService接口，专门实现删除功能。具体调用方可以根据实际需要实现各自需要的一个或一组接口。

### Dependency inversion principle（依赖倒置原则）
- 高层模块不应依赖于底层模块，二者都应该依赖于抽象。即：高层模块和底层模块共同依赖同一个抽象，面向抽象类或接口编程。
- 抽象不应该依赖实现细节，细节应该依赖抽象。

传统的从上到下设计方式是逐级依赖，即高层模块->级模块->底层模块。这样高层模块就依赖底层模块了，当某一模块需要修改，可能牵一发而动全身，影响较多不易维护。

而**依赖倒置**，就是高层模块->抽象层<-底层模块，使得它们同依赖抽象层，这样减少了类之间的耦合性，不同模块都可独立针对接口/抽象进行并行开发，可维护性大大增加。

--------
## 布隆过滤器
### 目的
解决当需要存储大量数据时，如何以最少的内存判断某个元素**是否存在于集合中**。

### 设计理念
**尽可能节省空间的情况下快速判断元素是否存在**，及时这意味着引入一定的误报风险。

### 应用场景
布隆过滤器设计的场景更倾向于**优化查询效率**和**节省存储空间**。允许某个元素“可能存在”而不是“完全存在”，就能大幅节约存储空间，尤其适用于对查询正确性要求不苛刻的场景。

布隆过滤器应用于缓存系统、垃圾邮件过滤、网页URL去重、集合重复元素判别、查询加速等多个场景。

### 基本原理
布隆过滤器的核心思想可以简化为**位数组**和**多个哈希函数**的结合。

1. 位数组  
   布隆过滤器使用一个长度为 m 的位数组，每一位都初始化为 0。这些位将用于表示元素的存在情况。

2. 多个哈希函数  
   布隆过滤器配备了 k 个独立的哈希函数。每个哈希函数都会为输入的元素生成一个 0 到 m-1 之间的索引值，也就是将元素“映射”到位数组中的某个位置。  
   通过多个哈希函数，**一个元素**会影响位数组中的**多个位置**，从而**降低哈希冲突**的风险。

3. 添加元素  
   当添加一个元素到布隆过滤器时，k个哈希函数会为该元素生成k个不同的索引值，并在位数组中将k个位置设置为1。
   
4. 查询元素  
   查询元素是否存在时，k个哈希函数会生成该元素的k个位置，并检查位数组中这个k个位置是否都为1。如果都为1，则表示元素**可能存在**；如果有任何一个位置为0，则确定元素不存在。

5. 误报率  
   布隆过滤器的一个关键特性是**可能误报**。因为位数组大小是有限的，多个元素可能会被不同的哈希函数映射到相同的位置上，导致某些不在集合的元素被误认为存在。  
   误报率与位数组的长度m，哈希函数的数量K，以及集合中的元素n有关。合理选择这些参数，可以在误报率和存储效率间做出权衡。

### 优缺点
优点：
1. 查询速度快。  只需检查元素被映射在位数组中的几个位置即可。
2. 高效节省存储空间。  布隆过滤器并不存储元素本身，使用位数组占位，使用的存储空间更少。
3. 不漏报。  如果某个元素不在集合中，就一定不存在。

缺点：
1. 有一定的误报率。可能会错误地判断某个不在集合中的元素存在。
2. 不可删除。因为位数组的位可能被多个元素**共用**，因为误报的特性，布隆过滤器无法保证删除的元素的确存在于集合中。

### 总结
- **以小博大**查询快  
  使用少量的存储空间，来获得对大量数据进行快速查询的效率。
- **分而治之**冲突小  
  使用多个不同的哈希元素对元素处理，生成不同的索引位置，降低哈希冲突。
- **位理万机**可误报不删除  
  多个元素可能被映射到同一个位置，从而出现误报，也正因此，一般不删除布隆过滤器中的元素。

资料引用：
<a href="https://zhuanlan.zhihu.com/p/720288602" target="_blank">https://zhuanlan.zhihu.com/p/720288602</a>

--------
## 缓存穿透、缓存击穿、缓存雪崩

### 1.缓存穿透
缓存穿透是指要查询的**key不在**缓存中，或**key不在**缓存**也不在数据库**中，导致大量的请求直接压到数据库中的情况。

解决方案：
1. 缓存空对象，即缓存null。
   这个方案存在2个问题：
   - 不存在的key理论上是无限的，这会导致内存占用过多，缓存性能下降。
   - 若数据库突然写入这类key的数据并未更新到缓存时，会导致缓存期间数据不一致。
2. 使用布隆过滤器等方式，对key值进行过滤，仅允许系统存在的key进行后续操作。
   
### 2.缓存击穿
缓存击穿是指缓存中的**热点数据**key过期，在过期的瞬间会有大量的请求（高并发）过来直接访问数据库，导致数据库压力增加。

解决方案：
1. 缓存预热：在程序启动时或高峰期时间通过定时任务提前将热点数据更新到缓存中，避免高峰期间的大量请求访问到数据库。
2. 加锁控制：利用分布式锁使得同一时间只有一个请求能访问到数据库并更新缓存，这样其他请求线程只能等待锁释放，得到锁之后已经可以读取到缓存中的数据
3. 设置数据永不过期：根据业务上的常用数据，可以酌情设置数据永不过期。
   
### 3.缓存雪崩
缓存雪崩是指缓存中大量key在**同一时间过期**，从而导致大量请求访问到数据库中，数据库随时可能宕机的现象。

解决方案：
1. 设置不同过期时间：给不同的key设置不同的过期时间，使失效时间尽量**分散**，避免同一时间过期。
2. 加锁或排队：缓存失效后，通过排它锁或队列的方式控制数据库写缓存的线程数量，使得操作串行化。
3. 多级缓存方案：酌情设置多级缓存。使得过期key可以从二级或多级缓存中读取到数据。
4. 限流措施：使用令牌桶等限流算法控制请求数量，减少服务压力。

### 总结
- 过滤防穿透。
- 预热防击穿。
- 雪崩要排队、分散限流降风险。

--------
## 数据库设计的规范化和反规范化

为了更好的理解数据库设计的规范化和反规范化，我们需要先弄清楚什么是函数依赖，以及函数依赖的分类，而要理解函数依赖，就要先明白什么是关系模式。

### 一、一些基本术语

1. 属性（Attribute）：在现实世界中，要描述一个事务常常取若干特征来表示。这些特征称为属性。例如学生通过学号、姓名、性别、系别、年龄、籍贯等属性来描述。
2. 域（Domain）：每个属性的取值范围对应一个值的集合，称为该属性的域。例如，学号的域是6位整型数；姓名的域是10位字符；性别的域为{男，女}等。
3. 目或度（Degree）：目或度指的是一个关系中属性的个数。
4. 候选码（Candidate Key）：若关系中的某一属性或属性组的值能唯一的标识一个元组，则称该属性或属性组为候选码。
5. 主键（Primary Key）：若一个关系中有多个候选码，则选定其中一个作为主键。
6. 主属性（Prime Attribute）：包含在任何候选码中的属性称为主属性，不包含在任何候选码中的属性称为非主属性（Non-Prime Attribute）。
7. 外键（Foreign Key）：如果关系模式R中的属性或属性组不是该关系的码，但它是其它关系的码，那么该属性集对关系模式R而言是外键。例如，客户与贷款之间的借贷联系c_1(c_id,loan_no)，属性c_id是客户关系中的键，所以c_id是外键；属性loan_no是贷款关系中的键，所以loan_no也是外键。
8. 全码（All-Key）：关系模型的所有属性组是这个关系模式的候选码，称为全码。例如，关系模式R(T,C,S)，属性T是教师，属性C是课程，属性S表示学生。假设一个教师可以讲授多门课程，某门课程可以由多个教师讲授，学生可以听不同教师讲授的不同课程，那么，要想区分关系中的每一个元组，这个关系模式R的码应为全属性T、C和S。

### 二、关系模式

#### 2.1 什么是关系模式

数据库的关系模式是关系型数据库中用于描述**数据库结构和数据之间关系**的一种方式。

它是对数据库关系（表）的逻辑结构进行定义，形式化表示为：R(U,D,dom,F)。

形式化的表示可以帮助设计者规范地描述数据库中的数据结构，以及数据之间的逻辑关系。这有助于确保数据的完整性和准确性，并为数据库的查询和操作提供一个清晰的基础。

通常，可以将关系模式简记：R(U)。

- R：表示关系的名称，代表数据库中的一张表或关系。
- U：表示关系R的属性集合。这些属性定义了关系中的列。
- D：表示属性集合U中每个属性的域或数据类型集合。域是对属性可能值的限制，确保每个属性的值都属于其指定的数据类型。
- dom：表示属性集合U中每个属性的值域，是属性到域的映像集合。
- F：表示关系R的函数依赖集合。

举个例子，假设我们有一张“学生成绩表”，存储的是学生信息和他们的成绩。用关系模式R(U,D,dom,F)来描述，其中：

- R：学生成绩
- U：{学号，姓名，课程，成绩}
- D：{整数，字符串，字符串，浮点数}
- dom：
    - 成绩：分数，例如90.5
    - 课程：课程名称，例如数学
    - 姓名：学生的名称，例如张三
    - 学号：具有唯一性的studentId，例如123456
- F：{学号->姓名，（学号，课程）->成绩}
  
以上关系模式，可以简记为：学生成绩(学号，姓名，课程，成绩)

### 三、数据依赖

#### 3.1 函数依赖

在上述关系模式的说明中，我们提到了函数依赖F，数据库中的函数依赖是描述关系型数据库中**表的属性之间相互依赖关系**的概念。

它反映了表中数据属性之间的逻辑关系，即一个属性或属性集是否能够决定另一个属性或属性集的值。

在关系型数据库中，一个关系（表）由多个属性（列）组成。函数依赖定义了这些属性之间的规则，说明了一个属性的值如何决定另一个属性的值。函数依赖有助于保证数据的准确性和一致性。

函数依赖主要有三种类型：

- 完全函数依赖
- 部分函数依赖
- 传递函数依赖

##### 3.1.1 完全函数依赖

当一个属性集合A完全决定另一个属性集合B时，我们说B完全函数依赖于A。记作A->B。这意味着A中的每个值都决定了B的一个唯一值。例如，（学号，课程）-> 成绩，这里学号和课程单独拿出来都不能决定成绩。只有学号和课程号一起才能决定一个成绩。

##### 3.1.2 部分函数依赖

当一个属性集合A的部分成员决定了另一个属性集合B时，我们说B部分函数依赖于A。例如，(学号，课程)->学生姓名，这里学生姓名只函数依赖于(学号，课程)中的子集学号，此时学生姓名部分依赖于（学号，课程）。

##### 3.1.3 传递函数依赖

当一个属性集合A通过中间属性集合B决定另一个属性集合C时，我们说C传递函数依赖于A。记作A->B->C。例如，学号->所在班级，所在班级->班主任，这里班主任依赖于所在班级，而所在班级又依赖于学号。

#### 3.2 多值依赖

多值依赖的定义：

设R(U)是属性集U上的一个关系模式，X,Y,Z是U的子集，并且Z=U-X-Y。关系R(U)中多值依赖X->->Y成立，当前仅当对R(U)的任一关系r，给定的一堆(x,z)值，有一组Y的值，这组值仅仅决定于x的值而与z值无关。

例1：

Table_MSC(M,S,C)中，M表示专业，S表示学生，C表示必修课，假设每个专业有多个学生，有一组必修课，设同专业内所有学生选修的必修课相同。

实例关系如下，按照语义，对于M中的每一个值m，S都有一个完整的集合对应，而不问C的值，所以M->->S，由于C与S的完全对称型，必然有M->->C。

|M|S|C|
|--|--|--|
|m1|s1|c1|
|m1|s1|c2|
|m1|s2|c1|
|m1|s2|c2|
|...|...|...|

例2：

关系模式Table_ISA(I,S,A)中，I表示兴趣小组，S表示学生，A表示某兴趣小组的活动项目。假设每个兴趣小组有多个学生，有若干活动项目，每个学生必须参加所在兴趣小组的所有活动项目，每个活动项目要求该兴趣小组的所有学生参加。

实例关系如下，对于I中的每个值i，S有一个完整的集合对应，而不问A的取值如何，所以I->->S，由于A与S的完全对称型，必然有I->->A成立。

也就是说，一个兴趣小组I对应若干学生S，他们是一对多关系(1:n)，是多值依赖I->->S；一个学生参加多个活动项目A，而一个活动项目又对应多个学生，他们之间是多对多的关系(n:m)；其实I与A没有直接关系，有的只是间接关系（借助S），只是因为S与A完全对称，所以可以推出兴趣小组与活动也是多值依赖I->->A（一对多1:m）。

**其实还有一个方法可以判断是否存在多值依赖**

以例1为例，找到属性M的相同值和属性S的不同值的任意两个元组，交换他们的C值，重新组成的元组如果可以在这个表内找到，那么就存在多值依赖。比如取第1行和第4行，将这两行的s1和s2互换，得到新元组(m1,s2,c1),(m1,s1,c2)，我们发现这两个元组在原表内存在（第3行和第2行），其他的也是这样，那么该关系模式就存在多值依赖。

#### 3.3 连接依赖

一个表可以分成几个子表，并将几个子表连接起来以后仍然是原来那个表。则称原来的那些属性之间具备连接依赖。

### 四、规范化

数据库设计规范化（Database Nomalization）是数据库设计中的一个重要方法，旨在优化数据库结构：

- 提高数据的一致性和完整性。
- 减少数据冗余，增强数据修改的灵活性。
- 并降低数据查询的复杂性。
  
规范化通常涉及将大表拆分为更小、更专门的表，并通过定义表之间的关系来连接这些表。

通常可以通过判断分解后的模式达到几范式来评价模式规范化的程度。范式从低到高依次为：

1. 第一范式（1NF）
2. 第二范式（2NF）
3. 第三范式（3NF）
4. 巴斯-科恩范式（BCNF）
5. 第四范式（4NF）
6. 第五范式（5NF）
7. 第六范式（6NF）

在实际应用中，3NF已经足够满足大多数数据库设计的需求。

#### 4.1 第一范式（1NF）

若存在学生表如下：

|StudentID|Name|Courses|
|--|--|--|
|1|Alice|Math,English|
|2|Bob|Math,Science|
|3|Charlie|Art,History|

Courses是学生所选的所有课程，这种表设计使得查询某课程被哪些学生选择变得复杂，并且在新增课程、取消选课时也要分解Courses字段才能进行处理。为了解决这个问题，提出了1NF。

1NF的目标是确保表中的每一列都是**不可分割的数据项**，主要确保每列的原子性。没有集合、数组、记录等复杂数据类型。

例如供应商和它所提供的零件信息，关系模式和函数依赖集F如下：

```

SPART(Sno,Sname,Status,City,Pno,Qty)
F={Sno->Sname,Sno->Status,Status->city,(Sno,Pno)->Qty}

```

具体关系如下表所示，可以看出，每列都是不可再分的数据项，所以是1NF的。

|Sno|Sname|Status|City|Pno|Qty|
|--|--|--|--|--|--|
|S1|精益|20|天津|P1|200|
|S1|精益|20|天津|P2|300|
|S1|精益|20|天津|P3|480|
|S2|盛锡|10|北京|P3|500|
|S3|东方红|30|北京|P2|280|
|...|...|...|...|...|...|

#### 4.2 第二范式（2NF）

在上述关系模式中，可以看到它的候选码是(Sno,Pno)，存在部分函数依赖（Sno可以单独推断出Sname和Status），这就导致其存在插入异常和删除异常的问题。

插入异常：是指按照关系模式实体完整性不能取空值或部分取空值（由于候选码只有一个，所以(Sno,Pno)也是主码）。这样当某个供应商的某些信息未提供时（如Pno），则不能插入数据。

删除异常：若供应商S3的P2零件销售完以后不再售卖，那么应删除元组，可S3又是客观存在的，不能因此删除。

而为了解决这些问题，就有了2NF。

2NF的目的是**消除部分函数依赖**，要求**非主键列必须完全依赖于整个主键，而不能仅仅依赖主键的一部分**。比如，为了消除部分函数依赖，我们可以将SPART关系分解为：

```

Supplier(Sno,Sname,Status,City)
Part(Sno,Pno,Qty)

```

因为分解后的关系模式Supplier的码为Sno，非主属性Sname，Status，City完全依赖于Sno，所以属于2NF；关系模式Part的码为(Sno,Pno)，非主属性Qty完全依赖于码，所以也属于2NF。

#### 4.3 第三范式（3NF）

在满足了2NF之后，继续分析可以发现，关系Supplier中存在传递函数依赖（Sno->Status,Status->City），导致其存在修改操作的不一致性问题：如Status=20对应的City从天津搬到了上海，则有可能导致一些Status=20的数据被修改，而另一些不被修改，导致数据产生不一致性，为了解决这个问题，就需要3NF。

3NF的目的是**消除传递函数依赖**，**非主键列必须直接依赖于主键，而不能依赖其他非主键**。

为了使前面的关系达到3NF，将Supplier进一步分解：

```
Supplier_1(Sno,Sname,Status)
Supplier_2(Status,City)
```

通过上述分解，数据库关系SPART转换为了Supplier_1,Supplier_2,Part这3个子模式，由于都达到了3NF，因此分解后的数据库模式达到了3NF。

#### 4.4 巴斯-科德范式（BCNF）

BCNF是3NF的一种改进形式，它有三点要求：

1. 所有非主属性对每一个码都是完全函数依赖
2. 所有的主属性对每一个不包含它的码，也是完全函数依赖
3. 没有任何属性完全函数依赖于非码的任何一组属性

简单的说就是，确保满足3NF，消除多维表中的多值依赖，确保表中的每个组合键都能唯一决定非键字段的值。

示例表格：

|学生编号|课程|教师|
|--|--|--|
|1|数学|张老师|
|1|英语|王老师|
|1|物理|张老师|
|2|英语|王老师|

BCNF范式后的表格：

|学生编号|课程|
|--|--|
|1|数学|
|2|英语|
|3|物理|


|课程|教师|
|--|--|
|数学|张老师|
|英语|王老师|
|物理|张老师|


#### 4.5 第四范式（4NF）

确保表满足BCNF，并且表中不存在多值依赖。消除多值依赖，既当两个非主键列之间存在多对多关系时，则应拆分到单独的表。

假设存在下表：

|学生编号|选课|爱好|
|--|--|--|
|1|数学|篮球|
|1|数学|羽毛球|
|1|英语|篮球|
|1|英语|羽毛球|

在该表中，候选键为(学生编号,选课,爱好)，即全部属性都是主属性，且不存在函数依赖，所以它是满足BNCF的，但是由于学生编号与选课之间，学生编号与爱好之间分别存在多值依赖且选课和爱好之间没有任何关系，所以这里存在数据冗余。没多一个选课都要添加2条记录（篮球和羽毛球）。

4NF的目的就是为了消除这种数据冗余，即消除关系中的多对多关系，将其拆分为多个一对多关系。

我们将上表拆分成两张表：S_C(StudentId,Course)和S_H(StudentId,Hobby)。

#### 4.6 第五范式（5NF）

在4.5节的例子中，如果补充一点约束：只有爱好为篮球的学生才可以选择数学和语文，只有爱好为羽毛球的学生才可以选择英语和化学。

此时学生编号、爱好和选课三个属性之间任意两个属性都存在多值约束，此时这三个属性就变成了连接依赖，不存在多值依赖，也就自然满足了4NF，而在4NF基础上，进一步消除其不由候选码隐含的连接依赖，就得到了5NF。

**消除其不由候选码隐含的连接依赖**：保证不存在任何依赖属性不为候选码的连接依赖。

例如上面所述的关系中，候选码是(学生编号，选课，爱好)，而在其连接依赖中：
- 学生编号->选课和学生编号->爱好之间的连接属性为学生编号；
- 爱好->选课和学生编号->爱好之间的连接属性为爱好；
- 爱好->选课和学生编号->选课之间的连接属性为选课；

可见它们的连接属性都不是候选码，所以不满足5NF。

为了使其满足5NF，我们需要针对其连接依赖进行拆分：R1(学生编号,选课)，R2(学生编号,爱好)和R3(选课,爱好)。

#### 总结

|范式|解析|
|--|--|
|1NF|每一个属性都为原子性|
|2NF|消除部分依赖，即每一个非主属性都完全依赖于任何一个候选码|
|3NF|消除传递依赖，即每一个非主属性都完全依赖于主键|
|BCNF|消除多值依赖，即每一个非主属性都完全依赖于主键，并且主键对每一个不包含它的码都是完全函数依赖|
|4NF|消除多对多依赖，各属性之间不允许拥有非平凡且非函数的多值依赖|


### 五、反规范化

在关系模式的规范化过程中，会导致关系的概念越来越单一化，在响应用户查询时，往往需要涉及多表的关联操作，导致查询性能下降。

为此需要对关系模式进行修正，对部分影响性能的关系模式进行处理。包括分解、合并、增加冗余属性等。这种修正称为反规范化设计。

反规范化设计通过有意地违反数据库设计中的范式原则，将数据冗余存储在多个表中，通过减少表之间的连接来提高查询性能。但是反范式设计也会增加数据冗余，增加数据更新和维护的难度。

反规范化设计不应与从未进行过标准化的数据库相混淆。常见的反规范化操作有：

- 冗余列：在多个表中存储相同的列，以避免连接操作。
- 派生列：将需要计算的列存储在表中，以避免计算开销。
- 表重组：将多个表合并成一个表，以减少连接操作。
- 表分割
  - 水平分割
  - 垂直分割

**总结**
- 冗余相同列，派生计算列，旨在减少连接或计算开销。
- 眼光从列放到表，表个数多可合并重组，数据量多可行列分割。
  行分割分维度分压力，列分割列主码分不同。
  

反规范化设计会在数据库中形成数据冗余，为解决**数据冗余**带来的**数据不一致**问题，设计人员往往需要采用**额外数据同步**的方法来解决数据不一致性。常见的方法有：

  - 事务控制：通过事务机制确保数据修改操作的原子性、一致性、隔离性和永久性。
  - 定期批量处理同步：通过定时批处理程序定时将相关表的冗余数据进行更新，确保数据一致性。
  - 触发器同步：是指在数据修改操作发生时自动触发响应的更新操作，保持数据一致性。


#### 5.1 冗余列

#### 5.2 派生列

#### 5.3 表重组

#### 5.4 表分割

表分隔是指将一个大表根据某些特定条件分隔成多个小表。每个小表只包含部分数据，但这些小表共同构成原来的大表。

这种方法可以有效地利用分布式数据库系统的特性，通过将数据分布在不同的服务器上，可以显著地提高查询性能和数据处理能力。

##### 5.4.1 水平分割

水平分割是根据数据行的特点进行分割，分割之后所得的所有表的结构都相同，而存储的数据不同。

例如我国的身份证号码若放在一个表中，由于我国人口众多，因此数据量很大，进行身份查询的效率会很低。这是可以按省份对它进行水平分割，把不同区域的身份信息存储在不同的表中，查询时只需根据省份代码查询相应的表，显著提高查询效率。

水平分割会增加应用的复杂度，特别是汇总数据时需要从不同的表或库中合并。有时候这种复杂性会超过它所带来的有点因此，综合考量表中数据具备很好的独立性时，就适合采用这种办法。

##### 5.4.2 垂直分割

垂直分割是根据数据列的特点进行分割，分割之后所得的所有表都含有主码列外其余列都不相同。

一般在一个表中某些列常用，而某些列不常用时采取垂直分割，把常用列和不常用列分开存储，从而提高查询效率。自然其缺点是若需汇总数据，则需要使用类似join的操作进行合并。

--------
## Redis

Redis是一个高性能的键值存储，它支持多重丰富的数据结构。每种结构都有其特定的用途和底层实现。

### Redis支持的八种数据类型

表格举例Redis常用的数据类型与业务功能对照：

|数据类型|存储的值|可实现的业务功能|
|--|--|--|
|String|字符串、整型或浮点数|用户帖子的评论计数器|
|List|列表|支持粉丝列表功能；每个用户的发布/订阅列表可以表示为一个列表|
|Set|无序集合|每个用户的好友可以表示为一个集合（共同好友功能）；每个帖子的标签也可以表示为一个集合|
|Hash|包括键值对的无序散列表|用户信息的结构化存储|
|ZSset|有序集合|排行榜功能|


#### 1.字符串（String）

文本、数字、二进制数据等。它在Redis内部以动态字符串（SDS，Simple Dynamic String）的形式存储，以节省内存。

#### 2.哈希（Hash）

hash是键值对的集合，适合表示对象的属性。最常用的是存储对象。内部实现主要有2种：

- 压缩列表（ziplist）：当哈希数量较少且每个键值对的长度较短时使用。
- 哈希表（hashtable）：当哈希数量增多或其中某个键或值变长后，自动转为哈希表。

#### 3.列表（List）

列表是一组有序的字符串，可以从列表的头部或尾部添加或删除元素。内部实现有2种：

- 压缩列表（ziplist）：元素数据量较少且每个元素较短时使用
- 双向链表（LinkedList）：元素数量较多时，会自动转为双向链表。

#### 4.集合（Set）

集合是无序且唯一的字符串集合。内部采用哈希表（hashtable）实现。哈希表的键是集合的值，值是null。

#### 5.有序集合（ZSet / Sorted Set）

有序集合类似Set，但每个元素都会关联一个分数（Score），元素按分数排序。内部使用一种结构：跳表和哈希表。

- 跳表（skiplist）：快速实现范围查询和排序
- 哈希表（hashtable）：快速定位元素

#### 6.位图（BitMap）

位图将字符串值视为一个位数组，可以进行位操作。内部存储采用字符串，最大长度可达512MB。

- 字节数组（byte array）：实际存储位图数据的结构，是一个连续的内存区域。

#### 7.HyperLogLog

HyperLogLog是基数估算数据结构，用于估算不重复元素的数量。利用概率算法实现，误差率约0.81%。用于大规模数据去重计数。

- 稀疏矩阵（Sparse Representation）：当元素少时，用压缩方法存储。
- 密集矩阵（Dense Representation）：当元素多到一定程度时，转为密集表示。


#### 8.地理空间（Geospatial）

Redis的地理空间拓展允许存储地理坐标，并提供地理范围查询、距离计算等功能。内部试用有序集合（Sorted Set）数据类型实现，利用GeoHash编码。

- GeoHash编码：将经纬度编码为字符串，保证地理位置靠近的两个编码也是靠近的。
- 跳表（skiplist）和哈希表（hashtable）：与有序集合共享的实现，支持半径查询和排序。

### Redis的分布式架构

#### 主从模式

Master-Slave模式是最简单的一种分布式架构。有一个主节点和一个或以上的从节点。

原理：
- 主节点：负责处理写操作（写入、更新、删除）
- 从节点：负责处理读操作，同时从主节点同步数据，保证数据一致性。

优点：
- 读写分离，提高读性能，减少写节点的压力。
- 主节点故障时，从节点可以升级为主节点，保证服务的高可用性。

缺点：
- 单点故障：如果主节点挂了，需要手动切换从节点为主节点。
- 写操作压力集中在主节点，拓展性有限。

#### 哨兵模式

Sentinel模式是主从模式的扩展，通过监控主节点的状态，自动将主节点升级为从节点，保证服务的高可用性。在主从模式的基础上增加了监控和自动故障转移功能。

原理:
- 哨兵节点：独立于主从节点的监控进程，负责监控主从节点的状态。
- 当主节点故障时，哨兵节点会自动选举一个从节点作为新的主节点，并通知客户端更新连接信息。

优点：
- 自动故障转移，减少人为干预。
- 提高系统的高可用性和稳定性。

缺点：
- 哨兵节点自身也可能有单点故障，需要配置多个哨兵节点互相监控。
- 实现相对复杂，需要额外的配置和维护。
  
**总结**
- 一主多从，读写分离又分工。主从切换要手动，哨兵监控来捉刀。
- 哨兵额外需配置，又怕单点出问题。
- 并发高又数据大，集群分片用哈希。

#### 集群模式

Cluster是Redis提供的一种更复杂、更强大的分布式解决方案，适用于大规模数据和高并发场景。

原理：
- 数据分片（Sharding）：将数据分布到多个节点上，每个节点只存储一部分数据。
- 每个节点既可以是主节点也可以有对应的从节点，形成一个集群。

优点：
- 高可用性：集群内的节点可以相互备份。
- 高拓展：可以方便地增加和减少节点来拓展或缩减集群容量。
- 数据均衡：通过分片技术，避免了单点写操作的瓶颈。

缺点：
- 实现复杂，需要了解和配置较多的参数。
- 节点间的通信和数据一致性问题需要特别关注。

##### Redis集群切片的几种常见方式

- 哈希求余。
  借助哈希函数，把一个key映射到整数，根据分片数量求余，得到的余数即为数据要分配到的分片位置。
  这个方法实现逻辑简单，分片数量越多，存储能力越高。但一旦集群需要扩容，存储的数据就可能发生变动，需要重新分配。

- 一致性哈希算法。
  为了解决哈希求余算法因扩容可能导致的数据搬运问题，就有了一致性哈希算法。通过一致性哈希算法，将每个服务节点进行哈希运算，映射到哈希环上，再将数据键进行哈希运算，映射到哈希环上，之后一般通过顺时针查找到最近的节点进行存储。每个节点负责一个片区的数据。
  这个方法能够高效扩容，降低了数据搬运的成本，但在节点数量较少时可能存在数据倾斜问题。

- 哈希槽分区算法。
  这为了解决一致性哈希算法在节点数量较少时可能发生的数据倾斜问题，引入了槽的概念，这是redis真正采用的分区算法。
  算法是对键进行哈希算法，然后取算法结果的低16位，与槽的数量进行模运算，得到的余数就是这个key所属的槽。
  hash_slot=crc16(key)%16384，相当于16*1024或16k（用来计算hash值的算法）。
  将整个数据集划分为16384个哈希槽，分配到不同的分片节点，每个节点负责一部分哈希槽的数据。虽然不是严格意义的均匀，但分片上的数据已经是比较均匀的了。

**总结**
- 单独哈希怕变动
- 一致时针会倾斜
- 定好槽片再参与，求模分区较均匀。

### Redis的持久化

Redis是内存数据库，宕机会丢失数据，Redis重启后快速恢复数据，所以需要提供持久化机制。

Redis提供两种持久化方式：
- RDB（Redis Database）（默认开启）
- AOF（Append Only File）

#### RDB

RDB是Redis默认的存储方式，持久性是以指定的间隔将内存数据写入到磁盘中，生成一个快照文件。

触发快照的方式：
1. 符合自定义配置的快照规则。
2. 执行save或bgsave命令。
3. 执行flushall命令。
4. 执行主从复制操作（第一次）。

优点：
- RDB是二进制压缩文件，占用空间小，便于传输（传给Slave）；。
- 主进程fork子进程，可以最大化Redis性能。
- 使用RDB恢复数据比较快。

缺点：
- 不保证数据完整性，可能会丢失最后一次快照以后更改的所有数据。
- 父进程在执行fork子进程的操作指令时如果主进程过大会阻塞。

#### AOF

AOF在默认情况下是不开启的。开启后Redis将所有对数据库进行过**写入命令（及其参数）（RESP）记录到AOF文件**，以此达到记录数据库状态的目的。这样当Redis重启后只要按顺序回放这些命令就会恢复到原始状态了。

AOF会记录过程，RDB只管结果。

AOF原理：
- 命令传播。每当命令函数成功执行之后（主要是写命令），命令参数都会被传播到AOF程序中。
- 缓存追加。AOF程序根据收到的命令写入AOF缓存
- 文件写入和保存。AOF缓存内容别写到AOF文件末尾，如果设定的AOF保存条件被满足，将写入的内容真正保存到磁盘中。

AOF重写：
Redis可以在AOF体积变得过大时，自动在后台fork子进程对AOF进行重写。**重写后的新AOF文件包含了恢复当前数据库所需的最小命令集合**。AOF重写并不需要对原有的AOF文件进行任何写入和读取，它针对的是数据库中键的当前值。


#### 比较

|比较|RDB|AOF|
|-|-|-|
|数据文件大小|小，二进制压缩存储，存的是数据库某时刻的快照|大，文本存储（混合）|
|磁盘更新频率|更新频率较低，可配置，适合对数据实时要求不是很高的场景|有3种保存模式，默认每秒保存一次，更新频率高|
|数据安全|低，RDB配置会丢失最后一次快照之后的数据|高，AOF设置为每秒保存一次，则最多丢失2秒的数据|
|数据一致性|低，RDB每隔一段时间才进行快照，数据可能丢失或不一致|高，AOF记录了几乎所有的数据库更新命令|
|重启性能|快，只需加载最近的快照即可|慢，因为需要重放所有写命令|

#### 应用场景

- 内存数据库。使用rdb+aof混合存储，数据不容易丢。
- 缓存数据库。使用rdb性能高。
- 不建议只是用aof（性能差）。
- 数据还原时，采用rdb+aof配置的，会优先使用aof还原数据，因为aof文件比rdb更新频率高。只是用rdb时才只还原rdb。

### Redis的内存管理

为了更好的管理内存，Redis提供了一些管理方案，包括过期策略和内存淘汰。

#### 过期策略

对每个Key设置过期时间。Redis提供了Expire与ExpireAt两个命令设置过期时间，ExpireAt是设置过期时间戳，Expire是设置过期秒数。当到达过期时间后利用专门的过期策略对Key进行删除。

##### 1.定期删除

类似一个守护线程，每间隔一段时间就执行一次（redis.conf的hz选项可配置），随机抽取一部分过期的key进行删除。

##### 2.惰性删除

因为定期删除随机抽取key进行删除，明显会遗漏很多过期key，因此还会有惰性删除。

惰性删除是当查询某个key时，判断该key是否已过期，过期则从缓存中删除，同时返回空。


#### 淘汰机制

无论**定期删除**还是**惰性删除**，都是一种不完全精准的删除策略，始终会存在已经过期的key还存在内存的场景。而且这2种过期策略都针对的是设置了过期时间的key，不适用于没有设置过期时间的key。

当Redis内存超出物理内存限制时，内存数据会开始和磁盘产生频繁的交换，交换会让Redis的性能急剧下降。所以Redis还提供了内存淘汰策略，用来筛选淘汰指定的key。

在redis.conf中，参数`maxmemory <bytes>`来设定最大内存（一般会将该参数设置为物理内存的四分之三），便会触发内存淘汰策略。

内存淘汰策略通过`maxmemory-policy`进行配置，目前redis提供了一下几种：
- noeviction
  默认淘汰策略。不会淘汰任何数据，当使用内存超过最大值时，再有写请求会返回错误。
- volatile-lru
  有过期时间的key，淘汰**最近最少使用**的键，即删除使用的时间戳最远的；
  没有过期时间的key，不会进行淘汰，这样可以保证需要持久化的数据不会丢失。
- allkeys-lru
  所有key，而不只是过期的key集合都会根据LRU算法进行淘汰。
- volatile-ttl
  对设置了过期时间的key，计算剩余寿命ttl值，ttl越小的优先被淘汰。
- volatile-random
  对所有设置了过期时间的key，随机淘汰。
- allkeys-random
  所有key随机淘汰。
- volatile-lfu
  对设置了过期时间的key，淘汰一段时间内**使用频率最低**的键，即删除计数器最少的。
- allkeys-lfu
  对所有key采取LFU算法进行删除。

我们可以通过前缀将它们分为2类，volatile-与allkeys-，这两类策略的区别在于二者选择要删除的key时字典不同。

下面介绍下LRU与LFU。

##### LRU
LRU， Least Recently Used缩写，也就是最近很少使用。当内存不够时，每添加一条数据，都要抛弃一条最久时间没有使用的旧数据。

LRU是基于链表结构实现的，链表中的元素按操作顺序从前到后排列，最新操作的键会被移动到表头，当需要进行内存淘汰时，只需要删除链表尾部的元素即可。

Redis并没有使用标准的LRU实现方法，而是近似LRU的策略进行了优化，平衡了时间与空间的效率。*tips：一个key上一次的访问时间存储在redisObject的lru字段中。*

LRU在某些情况下仍然存在一些问题：假设有一个节点数据很久没有访问了，偶然间被访问了一次，lru字段被更新，那么在LRU策略下，这个节点会被保留。但显然这个key并不是我们想保留的数据，为了解决这一问题，便有了LFU。

##### LFU
LFU，Least Frequently Used缩写，即一段时间内最不常用的。它和key的使用次数有关。原理是：根据key最近被访问的频率进行淘汰，比较少访问的key优先淘汰。

相比LRU算法，LFU增加了访问频率这样的一个维度来统计数据的热点情况，LFU主要使用了两个双向链表去形成一个二维的双向链表，一个用来保存访问频率，另一个用来保存访问频率相同的所有元素，其内部按访问时间排序。

- 当添加元素的时候访问频次默认为1，于是找到相同频次的节点，然后添加到相同频率节点对应的双向链表的头部。
- 当元素被访问的时候就会增加对应的key访问频率，并且把访问的节点移动到下一个频次的节点。

LFU算法通过使用频率和上次访问时间来标记数据的热度，相比LRU算法，可以真正达到非热点数据的淘汰，但也因为增加了访问频率的维度，其实现的复杂度比LRU更高。


##### 淘汰策略的选择

- 如果数据呈现幂等性分布（即部分数据访问频率高，而其余部分访问频率较低），建议使用allkeys-lru或allkeys-lfu。
- 如果数据呈现平等分布（即所有数据访问概率大概相等），建议使用allkeys-random。
- 如果需要通过设置不同的ttl来确定数据过期的顺序，建议使用volatile-ttl。
- 如果你想让一些数据可以长期保存，而一些数据可以消除，建议使用volatile-lru或volatile-random。

由于设置expire会消耗额外的内存，如果你打算避免Redis内存浪费这一项上，可以选择allkeys-lru策略，这样就可以不再设置过期时间，搞笑利用内存。

#### 使用建议

虽然Redis提供了内存淘汰策略，但我们最好还是精简对Redis的使用，尽量不要淘汰内存数据。下面是一些使用建议：
- 不要放垃圾数据，及时清理无用数据。
- key尽量都设置过期时间。
  对具有时效性的key设置过期时间，通过redis自身的过期key清理策略来降低key对于内存的占用，同时也能够减少业务的麻烦，不需要定期手动清理了。
- 单key不要过大。
  这种key造成的网络传输延迟会比较大，需要分配的输出缓冲区也比较大，在定期清理的时候也容易造成比较高的延迟，最好能通过业务拆分、数据压缩等方式避免过大key产生。
- 不同的业务如果共用一个业务的话，最好使用不同的逻辑db分开。
  这是因为Redis的过期key清理策略和强制淘汰策略会遍历各个db。将key分布在不同db有助于过期key的及时清理。另外不同业务使用不同db有助于问题排查和无用数据的及时下线。



## Memcache与Redis的区别和联系

Memcache就是一个数据库，但是数据存储在内存中。常用来做缓存服务器，例如缓存数据库查询结果，缓存静态页等以减少数据库的访问。

memcache适合存储的数据有：

- 访问比较频繁，对安全性要求不高，丢失也无所谓的数据。
- 数据更新比较频繁的状态数据，比如用户的在线状态。
- memcache是以k-v形式存储，单个键值不能太大，不要超过1MB数据。

### Memcache与Redis能力比较

|能力|MemCache|Redis|
|-|-|-|
|数据类型|简单kv结构|多种数据结构（string/list/set/ZSet/hash）|
|持久化|不支持|支持|
|分布式存储|只能在客户端通过哈希分片/一致性哈希等分布式算法来实现分布式存储|有多种分布式方案，主从模式、哨兵模式、集群模式|
|多线程支持|支持|新版才支持|
|内存管理|有，私有内存池|无（2018年考题，存疑）|
|事务支持|不支持|有限|


## 数据库系统存储的比较

### 关系型数据库与文件系统存储比较

|比较|关系型数据库|文件系统|
|-|-|-|
|设计难度|结构设计需要符合关系模式，难度较大|针对特定应用系统设计，难度较小|
|数据冗余程度|遵守数据范式，数据冗余较少|以文件为维度，多个文件可能存在重复属性，数据冗余较大|
|数据架构|以数据库为中心组织、管理数据|以应用系统为中心组织、管理数据|
|应用拓展性|数据库独立于系统，容易在不同系统间共享数据|文件数据要符合特定应用系统要求，很难在不同的应用系统共享|

### 内存数据库与关系型数据库比较

|比较|内存数据库|关系型数据库|
|-|-|-|
|数据模型|键值对（key-value）|关系模式|
|读写性能|内存直接读写，性能高|依赖磁盘IO，性能较低|
|存储容量|基于机器内存大小存储，容量有限|基于磁盘存储，容量大|
|可靠性|依赖服务器运行和内存管理，恢复机制复杂，可靠性低|内建恢复机制，可靠性高|

--------
## 密码学

数据加解密是数据安全性的重要环节。

--------
## CRC16

CRC16， Cyclic Redundancy Check，是一种常用的循环冗余校验算法，用于检测和校验数据的完整性。

常用于通信协议、数据存储和数据传输等场景。

CRC16算法通过对数据进行一些列的位运算和异或操作来生成校验码，算法原理：
1. 初始化一个16位的寄存器为全1；
2. 将每个字节（8位）从高位到低位依次与寄存器进行异或操作；
3. 将每个字节进行循环左移8位，并重复步骤2；
4. 最终寄存器中的值即为生成的CRC16位校验码。


---
# layout: post
layout: post-custom
title: "系统架构师笔记-EP3"
---

>**万时定律**，10000小时定律。  
简单来说，要成为某个领域顶尖的专业人才，需要10000小时持续不断的练习。例如小提琴、足球、国际象棋、围棋等领域，无一例外都遵循这个定律。  
技术人员的成长需要对技术的热情和持续不断学习，思考，实践和总结。

## 大纲及分集

<a href="https://sustamp.github.io/notes-blog/2025/03/20/ruankao-outline.html" target="_blank">架构设计师考试大纲</a>

<a href="https://sustamp.github.io/notes-blog/2024/10/31/ruankao-study-notes.html" target="_blank">系统架构师笔记-EP1</a>

<a href="https://sustamp.github.io/notes-blog/2025/05/09/ruankao-EP2.html" target="_blank">系统架构师笔记-EP2</a>

## 4.软件工程基础知识
### 4.1 软件工程
#### 4.1.1 软件工程概述
##### 软件工程的发展历程和软件危机

软件危机的具体表现：
1. 开发进度难以预测
2. 开发成本难以控制
3. 功能难以满足用户期望
4. 软件质量无法保证
5. 软件难以维护
6. 缺少适当的文档资料

##### 软件工程的定义
- 【Barry Boehm】：（运用现代科学技术知识）设计并构造软件 以及为 **开发**、**运行**、**维护**这些程序所必须的**相关文件资料**。
- 【IEEE】：1.将 （系统化的、严格约束的、可量化的） 方法应用于软件的开发、运行和维护，即将**工程化**应用于软件。
- 【Fritz Bauer】：建立并使用完善的 **工程化原则**，以较经济的手段 获得能在实际机器上有效运行的可靠软件的一系列方法。

#### 4.1.2 软件过程模型一览表

（软件工程）过程是指：为获得软件产品，在软件工具的支持下有软件工程师完成的一系列软件工程活动，包括以下4个方面（**PDCA**）：
- P（Plan） ———— 软件规格说明。规定软件的功能及运行限制。
- D（Do） ———— 软件开发。开发出满足规格说明的软件。
- C（Check） ———— 软件确认。确认软件能够满足用户需求。
- A（Action） ———— 软件演进。软件在运行过程中不断改进以满足新的需求。

|模型|特征|
|-|-|
|瀑布模型|结构化方法。严格区分阶段（*上一个阶段的结果是下一个阶段的输入*），适合需求明确、文档齐全、风险控制弱的项目|
|原型模型|迭代法。适用于**需求不明确**的场合。有2个阶段：原型开发阶段（*模拟界面、类似软件、快速原型*），目标软件开发阶段（*根据原型理解需求后开发具体的目标软件*）|
|螺旋模型|迭代法。快速原型（*基础*） + 瀑布，强调**风险分析**。适用于大型、复杂、风险项目。|
|喷泉模型|面向对象方法。**复用好**、开发过程**无间隙**、节省时间|
|V模型|开发与测试（*验证*）相结合。主要内容是：1.测试分阶段：编码-单元测试（**扁担**）、详细设计-集成测试（**吉祥**）、概要设计-系统测试（**膝盖**）、需求分析-验收测试（**延续**），2.测试计划先行：详细设计阶段要做单元测试的计划、概要设计阶段要做集成测试的计划、需求分析阶段要做系统测试和验收测试的计划|
|变换模型|适用于形式化开发|
|智能模型|适用于基于规则的专家系统|
|快速应用开发（RAD）|基于构件的开发方法。当**模块化要求高**时 开发或复用构件、**用户参与**，不适用新技术。流程：业务建模、数据建模、过程建模、应用生成、测试与交付|
|敏捷模型|面向人的、适应性、迭代增量式开发过程|
|统一软件开发过程（RUP/UP）|**用例驱动**、架构为中心、迭代、增量。以阶段**里程碑**评估项目是否检修|
|基于构件的开发模型（CBSD）|可重用构建模型。基于构件的开发方法，自主开发或复用构件。|
|基于构件的软件工程（CBSE）|CBSE体现**购买而不是重新构造**的哲学。可组装（*接口对接*）、可部署、文档化（*判断构件是否符合需求*）、独立性、标准化|
|逆袭工程||
|净室软件工程（CSE）|用数学表达来表示软件工程的过程，太严格、难实现|

> - UP：Unified Process，统一过程。
> - RUP：Rational Unified Process，是IBM Rational公司对UP的具体商业化实现，是一个详细的、可配置的软件开发流程框架。
> - RAD：Rapid Application Development，快速应用开发。
> - V模型：把 *V* 理解成：Validation，即验证。

#### 敏捷模型
##### 敏捷方法的主要特点
1. 敏捷方法是**适应性**（adaptive），而非预设型（predictive）。
2. 敏捷方法是**面向人的**（People-oriented），而非面向过程（Process-oriented）。
3. 迭代增量式的开发过程。（*小步快跑，很适合小型项目*）

> 口诀：AP + Sprint
> - 这里的AP在游戏里叫能力点/技能点：Ability-Point，我们用在这里加深记忆。
> - 敏捷模型的 能力点（AP） + Sprint，即 Adaptive + People + Sprint。

敏捷开发要求 开发人员有权做技术方面的决定，强调 相关人员之间的信息交流，提倡 面对面交流。

##### 敏捷方法一览表

|方法|要点|
|-|-|
|XP|沟通、简单、反馈、勇气，近螺旋式开发方法|
|SCRUM|**侧重于项目管理**，划分成sprint，快速迭代，增量交付|
|水晶方法|提倡**机动性方法**，拥有对 不同类型项目 非常有效的敏捷过程|
|特征驱动开发方法（FDD）|迭代开发模型，认为有效软件开发需要3要素：人、过程、技术|
|开放式源码|其他方法强调人员集中地点办公，开放式源码的程序员**在地域上分布很广**|
|自适应软件开发（ASD）|核心：猜测、合作、学习，是3个非线性的、重叠的开发阶段|
|动态系统开发方法（DSDM）|倡导**以业务为核心**|

> - XP：Extreme Programming，极限编程。
> - FDD：Feature Driven Development，特征驱动开发。
> - ASD：Adaptive Software Development，自适应软件开发。
> - DSDM：Dynamic System Development Method，动态系统开发方法。

##### 敏捷方法-极限编程（XP）
极限编程（eXtreme Programming）是一种近螺旋式的开发方法，将复杂的开发过程分解为一个个相对比较简单的小周期。XP方法体现了4大价值观：
1. **沟通** —— *加强face to  face 交流*
2. **简单** —— *不过度设计*
3. 反馈 —— 及时反馈
4. 勇气 —— 接受变更的勇气

12条过程实践规则：
1. 简单设计
2. 测试驱动
3. 代码重构
4. 结对编程
5. 持续集成
6. 现场客户
7. 发行版本小型化
8. 系统隐喻
9. 代码集体所有制
10. 规划策略
11. 规范代码
12. 40小时工作机制

##### 敏捷方法-SCRUM
SCRUM侧重项目管理，是一个增量的、迭代的敏捷软件开发过程。

![敏捷方法-SCRUM](https://sustamp.github.io/assets/pictures/ruankao/AgileDevelopment-SCRUM.png)

关于SCRUM的过程，下面内容介绍的足够详细（*来自 51cto 考题*）：

Scrum敏捷开发中，项目团队由Scrum主管、产品负责人和开发团队人员三种不同的角色组成，其开发过程由若干个Sprint（短的迭代周期，通常为2到4周）活动组成。

Product Backlog是在Scrum过程初期产生的一个**按照商业价值排序的需求列表**，该列表条目的体现形式通常为用户故事。在每一个Sprint活动中，项目团队从Product Backlog中挑选**最高优先级的用户故事**进行开发。被挑选的用户故事在**Sprint计划会议**上经过细化分解为任务，同时初步估算每一个任务的预计完成时间，编写Sprint Backlog。

在Sprint活动期间，项目团队每天早晨需举行**每日站会**，重新估算剩余任务的预计完成时间，更新Sprint Backlog、Sprint燃尽图和Release燃尽图。在每个Sprint活动结束时，项目团队召开**评审会议**和**回顾会议**，**交付产品增量**，总结Sprint期间的工作情况和问题。此时，如果Product Backlog中还有**未完成的用户故事**，则项目团队将开始筹备**下一个Sprint活动迭代**。

##### 敏捷模型的最佳实践（论文？）

![敏捷方法-SCRUM](https://sustamp.github.io/assets/pictures/ruankao/AgileDevelopment-Practice.png)


#### 统一过程模型（RUP/UP）
RUP类似一个在线指导者，在所有方面和层次为程序开发提供指导、模板和实例支持

##### RUP的核心概念和特点

> who + 

##### RUP的生命周期
##### 4+1视图模型

#### 能力成熟度模型（CMMI）

> CMMI: Capability Maturity Model Integration

##### CMMI的等级、关键过程域和过程目标

> 口诀：初管 定 良优

|级别|要点|能力或目标|
|-|-|-|
|初始级|无序、混乱的，软件产品的成功依赖**个人**|目标：要具备基本管理，达到已管理级|
|已管理级|项目级控制。已建立**项目管理过程**|项目计划、跟踪管理、质量保证|
|已定义级|组织标准化。软件过程均已**文档化**、**标准化**|标准流程库（*如开发、测试、项目管理模板*）、流程可裁剪、风险管理|
|量化管理级|数据驱动。有详细的度量标准|关键过程有统计数据（*缺陷率、生产率*）、能预测和管理偏差、改进基于数据而非经验|
|优化级|持续改进，鼓励创新|主动识别和消除过程问题、引入新技术（*如AI*）、鼓励创新|


### 4.2 需求工程
哪些是需求？ ———— 业务需求、用户需求、功能需求

需求工程的主要活动：
1. 需求获取
2. 需求分析
3. 形成需求规格
4. 需求确认与验证
5. 需求管理
   - 变更控制
   - 版本控制
   - 需求跟踪
   - 需求状态跟踪

#### 需求获取

#### 需求变更
需求变更是常态，引起需求变更的原因有很多：
1. 需求获取不完整
2. 理解偏差
3. 业务变化
4. 合理的需求改进

##### 变更控制过程

|过程|要点|
|-|-|
|问题分析和变更描述|分析变更 ——> 更明确的变更描述|
|变更分析和成本计算|分析和评估变更带来的影响，决定是否执行变更|
|变更实现||

#### 需求追踪
需求追踪哪些东西？ ———— 需求、体系结构、设计部件、源代码模块、测试、帮助文件和文档

需求追踪的目的： **建立一致性** （从需求 —— 设计 —— 开发 —— 测试）

需求追踪的方法：
- 正向追踪：from SRS to every result
  - 这里的`result`指的是设计文档、代码、测试用例等工作成功，下同。
- 反向追踪：find result in SRS

### 4.3 系统分析与设计
#### 结构化分析
结构化分析是在系统分析阶段进行系统建模的过程，会建立以下3种模型：
- 数据模型：实体关系图（E-R图）
  - 包含数据元素和联系
- 逻辑模型：数据流图（DFD）
  - 数据流图包含了：外部实体、加工逻辑、数据流、数据存储
- 行为模型：状态转换图（STD）
  - 包含行为状态的变化过程
  
3种模型各自环抱，形成 数据字典 放在核心。

#### 结构化设计
##### 耦合
耦合表示模块间的联系程度。

以下是 模块间 耦合类型一览表：

> 口诀：非鼠标 可通宫内

|耦合类型|描述|举例|
|-|-|-|
|1.非直接耦合|模块间没有直接耦合关系，它们之间的联系完全是通过上层模块的控制和调用|两个完全独立的模块。（*现实中少见*）|
|2.数据耦合|模块间仅通过**参数传递**基本数据类型交互|`calculate(a, b)`，仅传入 int a, b。（*最佳实践，低耦合*）|
|3.标记耦合|模块间通过**复合数据结构**（如对象、结构体）交互，但仅使用部分字段|`updateUser(user)`，但只修改 user.name。（*稍高耦合，注意数据冗余*）|
|4.控制耦合|一个模块通过**控制信号**（如标志位）影响另一模块的逻辑|`process(data, is_urgent)`，is_urgent 控制流程。（*较高耦合、慎用*）|
|5.通信耦合|多个模块通过共享同一组输入或输出数据来间接交互|共享输入：如配置文件，共享输入：日志文件、消息队列。（*难维护，当共享源出问题，其他也会出问题*）|
|6.公共耦合|多个模块共享同一全局数据区（如公共内存、静态变量、通信区）|多个模块读写同一个缓存，`static List cache`。（*高耦合，调试困难*）|
|7.内容耦合|一个模块直接访问或修改另一模块的**内部数据**；一个模块有多个入口;两个模块间有重叠代码|模块A直接修改模块B的私有变量。（*最差实践，避免使用*）|

> 从上到下，耦合度逐渐增高。

##### 内聚
内聚表示模块内的元素之间的联系紧密程度。高内聚的模块应当恰好做目标单一的一个功能。

关于模块内的元素不同内聚类型，见下表：

> 口诀：工序 通过 是罗欧

|内聚类型|描述|举例|
|-|-|-|
|1.功能内聚|完成一个功能，各个部分协同工作，缺一不可||
|2.顺序内聚|模块内的处理步骤必须顺序执行，且前一步的输出是后一步的输入||
|3.通信内聚|模块内的功能元素通过操作同一组数据结构而结合在一起|读取学生成绩、处理学生成绩、存储学生成绩|
|4.过程内聚|模块内的功能元素按**特定的次序**执行，但步骤间可能无直接数据传递|验证订单、扣款、生成发票|
|5.时间内聚|模块内的功能元素在**同一时间段内被执行**，但逻辑上可能没有直接关系|初始化模块|
|6.逻辑内聚|模块内的功能元素基于某种逻辑条件选择性执行|错误处理模块、信息分发模块|
|7.偶然内聚|完成一组没有关系或松散关系的功能||

> 从上到下，内聚紧密程度逐渐降低。

##### 概要设计
概要设计的主要任务是 确定系统的结构，对系统进行 模块划分，确定每个模块的功能、接口和模块间调用关系。

输出：系统结构图

##### 详细设计
详细设计主要任务是 设计每个模块的实现细节。

详细设计的表示工具有：
- 图形工具（*表示过程细节*）
  - 业务流图、程度流程图、问题分析图（PAD：提供了5种控制结构，并允许递归调用）
- 表格工具
  - 用表格描述过程的细节，参数或条件
- 语言工具
  - 利用高级语言或伪代码

##### 结构化编程
结构化程序设计采用 自顶向下、逐步求精的设计方法，划分模块通过 顺序、选择（*分支*）、循环 的控制结构进行连接，并且只有一个入口一个出口。

结构化程序设计的原则可以归纳为 32个字：
- 自顶向下、逐步求精
- 清晰第一，效率第二
- 书写规范、缩进格式（???）
- 基本结构、组合而成

#### 面向对象分析

#### 面向对象设计


#### 4.3.1 结构化方法
#### 4.3.2 面向对象方法
#### 4.3.3 其他方法

### 4.4 软件测试
### 4.5 净室软件工程（CSE）
### 4.6 基于构件的软件工程（CBSE）
### 4.7 软件项目管理

## 5.数据库设计基础知识
### 一、基本术语

#### 属性（Attribute）
- 在现实世界中，要描述一个事务常常取若干特征来表示。这些特征称为属性。
- 例如学生通过学号、姓名、性别、系别、年龄、籍贯等属性来描述。
  

#### 域（Domain）
- 每个属性的取值范围对应一个值的集合，称为该属性的域。
- 例如，学号的域是6位整型数；姓名的域是10位字符；性别的域为{男，女}等。


#### 超键（Super Key）
- 超键是一组属性。能够唯一标识表中每一行记录。
- 超键可以包含多余属性，即便不是必须的，结合起来也可以唯一标识记录。


#### 候选键（Candidate Key）
- 候选码是最小的超键。即从超键中移除任何属性后，它就不再能唯一标识表中的每一行记录。


#### 主键（Primary Key）
- 若一个关系中有多个候选码，则选定其中一个作为主键。
- 主键也是最小的超键。一旦选定，应尽量避免更改。


#### 主属性（Prime Attribute）
- 包含在任何候选码中的属性称为主属性。


#### 非主属性（Non-Prime Attribute）
- 不包含在任何候选码中的属性称为非主属性。


#### 外键（Foreign Key）
- 如果关系模式R中的属性或属性组不是该关系的码，但它是其它关系的码，那么该属性集对关系模式R而言是外键。
- 例如，客户与贷款之间的借贷联系c_1(c_id,loan_no)，属性c_id是客户关系中的键，所以c_id是外键；属性loan_no是贷款关系中的键，所以loan_no也是外键。

#### 全码（All-Key）
- 关系模型的所有属性组是这个关系模式的候选码，称为全码。
- 例如，关系模式R(T,C,S)，属性T是教师，属性C是课程，属性S表示学生。假设一个教师可以讲授多门课程，某门课程可以由多个教师讲授，学生可以听不同教师讲授的不同课程，那么，要想区分关系中的每一个元组，这个关系模式R的码应为全属性T、C和S。

### 二、关系模式

数据库的关系模式是关系型数据库中用于描述**数据库结构**和**数据**之间**关系**的一种方式。

它是对数据库关系（表）的逻辑结构进行定义，形式化表示为：`R(U,D,dom,F)`。

形式化的表示可以帮助设计者规范地描述数据库中的数据结构，以及数据之间的逻辑关系。这有助于确保数据的完整性和准确性，并为数据库的查询和操作提供一个清晰的基础。

通常，可以将关系模式简记：`R(U)` 。

- R：表示关系的名称，代表数据库中的一张表或关系。
- U：表示关系R的属性集合。这些属性定义了关系中的列。
- D：表示属性集合U中每个属性的域或数据类型集合。域是对属性可能值的限制，确保每个属性的值都属于其指定的数据类型。
- dom：表示属性集合U中每个属性的值域，是属性到域的映像集合。
- F：表示关系R的函数依赖集合。

举个例子，假设我们有一张`学生成绩表`，存储的是学生信息和他们的成绩。用关系模式`R(U,D,dom,F)`来描述，其中：
- R：学生成绩
- U：{学号，姓名，课程，成绩}
- D：{整数，字符串，字符串，浮点数}
- dom：
    - 成绩：分数，例如90.5
    - 课程：课程名称，例如数学
    - 姓名：学生的名称，例如张三
    - 学号：具有唯一性的studentId，例如123456
- F：{学号->姓名，（学号，课程）->成绩}
  
以上关系模式，可以简记为：`学生成绩(学号，姓名，课程，成绩)`

### 三、数据依赖

#### 函数依赖

在上述关系模式的说明中，我们提到了函数依赖F，数据库中的函数依赖是描述关系型数据库中表的**属性之间**相互依赖**关系**的概念。

它反映了表中数据属性之间的逻辑关系，即一个属性或属性集是否能够决定另一个属性或属性集的值。

假设现有如下关系模式`学生表`：

|学号|姓名|专业名|性别|出生日期|本学期学分|
|-|-|-|-|-|-|
|42014601|李梦|信管|女|2000-02-11|24|
|42014602|冯小羽|电商|男|2001-08-07|24|
|42014603|朱秀淳|财会|女|2001-09-07|24|
|42014604|曾敏能|物流|男|2001-10-18|24|

`学生成绩表`：

|学号|姓名|课程号|成绩|
|-|-|-|-|
|42014601|李梦|020114|100|

##### 平凡函数依赖
- 定义：设一个关系`R(U)`，`X`和`Y`为属性集U的一个子集，当X->Y时，如果Y ⊂ X，那么称：`X->Y`为**平凡函数依赖**。
- 例如：`(学号，姓名) -> 姓名`。

##### 非平凡函数依赖
- 定义：设一个关系`R(U)`，`X`和`Y`为属性集U的一个子集，若X->Y时，Y ⊄ X，那么称：`X->Y`为**非平凡函数依赖**。
- 举例：`(学号， 课程号) -> 成绩` 。

##### 完全函数依赖
- 定义：在`R(U)`中，X、Y为U的子集，若X->Y，且对X的任意一个**真子集Z**来说，Z->Y都不成立。那么称：`X->Y`为**完全函数依赖**。
- 举例：`(学号， 课程号) -> 成绩`。

*(学号，课程) -> 成绩。学号和课程单独拿出来都不能决定成绩。所以说 `成绩` 完全依赖于 `(学号，课程)`。*


##### 部分函数依赖
- 定义：在`R(U)`中，X、Y为U的子集，若X->Y，存在一个X的**真子集Z**，使得Z->Y，那么`X->Y`为**部分函数依赖**。
- 举例：`(学号，课程号) -> 姓名`

##### 传递函数依赖
- 定义： 在一个关系模式`R(U)`中，X、Y、Z为属性集U上的子集，如果X->Y，Y不能反推出X，且Y->Z，这时候X也可以推出Z，即 `X -> Y -> Z`，则`X->Z`为**传递函数依赖**。
- 举例：`学号 -> 班级`，`班级 -> 班主任`，所以`学号 -> 班主任`为传递函数依赖。

资料： [快速理解数据库函数依赖](https://blog.csdn.net/weixin_62714329/article/details/129806085)

##### 多值依赖
定义：
- 存在关系模式`R(U)`，X、Y、Z是U的子集，并且 Z = U-X-Y。
- **当前仅当**对R(U)的任一关系r，给定的一堆`(x,z)`值，有一组`y`的值，这组值仅仅决定于`x`的值而与`z`值无关。则**多值依赖** X->Y成立，

举例：  

`学生选课表(学号，专业，课程)`中，假设每个专业有多个学生，有一组必修课，设同专业内所有学生选修的必修课相同。

按照语义，给定一堆`(专业, 课程)`的值，有一组`(学号)`的值仅仅决定于`专业`，与`课程`无关。则称`专业->学号`是**多值依赖**。简单理解就是**一对多**关系(1:n)。

**其实还有一个方法可以判断是否存在多值依赖**

- 找到`专业`属性M的**相同**值和`学号`属性S的**不同**值的任意两个元组，**交换**他们的`课程`C值。
- 重新组成的元组如果可以在这个表内找到，那么就存在多值依赖。

##### 连接依赖

一个关系模式(表)`R(U)`可以分解为几个子表`R(A)`,`R(B)`，如果将几个子表连接起来以后仍然是原来那个表`R(U)`。则称原来的那些属性之间具备``连接依赖``。


### 四、规范化

数据库设计规范化（Database Nomalization）是数据库设计中的一个重要方法，旨在优化数据库结构：
- 提高数据的**一致性**和**完整性**。
- **减少**数据**冗余**。
- 增强数据**修改**的**灵活**性。
- **降低**数据**查询的复杂性**。
  
规范化通常涉及将**大表**拆分为更小、更专门的**小表**，并通过定义**表之间**的**关系**来**连接**这些表。

通常可以通过判断分解后的模式达到几范式来评价模式规范化的程度。范式从低到高依次为：

1. 第一范式（1NF）
2. 第二范式（2NF）
3. 第三范式（3NF）
4. 巴斯-科恩范式（BCNF）
5. 第四范式（4NF）
6. 第五范式（5NF）
7. 第六范式（6NF）

在实际应用中，**3NF**已经足够满足大多数数据库设计的需求。

#### 第一范式（1NF）

- 定义： 数据表中的每一列都是**不可分隔**的数据项，不包含重复列。
- 目的： 消除重复数据，确保每个字段都是原子性，减少数据冗余。

若存在学生表如下：

|学号|姓名|课程|
|--|--|--|
|1|Alice|Math,English|
|2|Bob|Math,Science|
|3|Charlie|Art,History|

Courses是学生所选的所有课程，这种表设计使得查询某课程被哪些学生选择变得复杂，并且在新增课程、取消选课时也要分解Courses字段才能进行处理。

#### 第二范式（2NF）

- 定义： 在1NF的基础上，**非主键**列**完全依赖**于**主键**，而不是主键的一部分。
- 目的： 消除**部分函数依赖**，进一步减少数据冗余。

例如供应商和它所提供的零件信息，关系模式和函数依赖集F如下：
- 供应商信息表`Supplier(Sno, Sname, Status, City, Pno, Qty)`
- 函数依赖F = {`Sno->Sname`, `Sno->Status`,`Status->city`, `(Sno,Pno)->Qty`}

具体关系如下表所示:

|Sno|Sname|Status|City|Pno|Qty|
|--|--|--|--|--|--|
|S1|精益|20|天津|P1|200|
|S1|精益|20|天津|P2|300|
|S1|精益|20|天津|P3|480|
|S2|盛锡|10|北京|P3|500|
|S3|东方红|30|北京|P2|280|
|...|...|...|...|...|...|


分析：
- 每列都是不可再分的数据项，满足1NF。
- 函数依赖：
  - `Sno -> Sname`, 
  - `Sno -> Status`, 
  - `Status -> city`, 
  - `(Sno,Pno)-> Qty`
- 候选键：
  - `(Sno, Pno)`

存在部分函数依赖：`(Sno, Pno) -> (Sname, Status)`。

`Sno`可以单独推断出`(Sname, Statu)`，这就导致其存在插入异常和删除异常的问题：
- 插入异常：是指按照关系模式实体完整性不能取空值或部分取空值。
  - 由于候选码只有一个，所以`(Sno,Pno)`也是主码。这样当某个供应商的`Pno`未提供，则不能插入数据。
- 删除异常：
  - 若供应商S3的P2零件销售完以后不再售卖，那么应删除元组，可S3又是客观存在的，不能因此删除。

为了消除部分函数依赖，我们可以将SPART关系分解为：
- `SupplierInfo(Sno, Sname, Status, City)`
- `Part(Sno, Pno, Qty)`

分解后的关系模式`Supplier`的码为`Sno`，非主属性`Sname`，`Status`，`City`完全依赖于`Sno`，所以属于**2NF**；

关系模式`Part`的码为`(Sno,Pno)`，非主属性`Qty`完全依赖于码，所以也属于**2NF**。

#### 第三范式（3NF）

- 定义：在2NF的基础上，**消除**非主属性之间的**传递依赖**，即任何**非主键列**都**不依赖**于其它**非主键**列。
- 目的：消除**传递依赖**，提高数据表的稳定性和一致性。

在满足了2NF之后，继续分析可以发现，关系`SupplierInfo`中存在**传递函数依赖**。
- `Sno->Status`和`Status->City`

导致其存在修改操作的不一致性问题：
- 如Status=20对应的City从天津搬到了上海，则有可能导致一些Status=20的数据被修改，而另一些不被修改，导致数据产生不一致性。
  
为了解决这个问题，就需要3NF。将`SupplierInfo`进一步分解：
- `Supplier_1(Sno, Sname, Status)`
- `Supplier_2(Status, City)`


#### 巴斯-科德范式（BCNF）

- 定义：在3NF的基础上，要求任何**非主键**列**不依赖**于**主属性**的**子集**。
- 目的：消除3NF中**主属性**对码的**部分依赖**和**传递依赖**。
  
假设：(这个例子可能并不够贴切)
- 某公司有若干仓库，
- 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
- 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。
- 每种物品在每个仓库中都有对应的数量。

表格数据如下：

|仓库|管理员|物品|数量|
|-|-|-|-|
|上海仓|张三|iPhone|30|
|上海仓|张三|iPad|20|
|广州仓|李四|小米13|50|
|北京仓|李四|华为Mate|30|

那么关系模式 `仓库表(仓库，管理员，物品名，数量)` 属于哪一级范式？

分析：
- 函数依赖：
  - `(仓库,物品) -> (管理员, 数量)` 
  - `(管理员, 物品) -> (仓库,数量)`
- 候选键：
  - `(仓库, 物品)` 
  - `(管理员，物品)`
- 主属性：
  - `仓库`
  - `管理员`
  - `物品名`
- 非主属性：
  - `数量`

非主属性完全依赖于候选键，**不存在**非主属性对候选键的**部分函数依赖**（满足2NF），也不存在**传递依赖**，所以它满足**3NF**。

但这个表存在如下问题：
1. 增加一个仓库，但没有存放物品，管理员信息也无法插入。
2. 清空仓库中的所有物品，同时把仓库、管理员信息也清掉了。

这是因为主属性`管理员`对候选键`(仓库，物品)`存在部分依赖，或者说`仓库`对`(管理员, 物品)`存在部分依赖，继续拆分表格来满足BCNF：
- `仓库(仓库名，管理员)`
- `库存(仓库，物品，数量)`


#### 第四范式（4NF）

- 定义：在满足3NF基础上，**消除**非平凡的**多值依赖**。
- 目的：处理表中**多**个**独立存在**的**多值关系**。

假设存在下表：

|学生编号|选课|爱好|
|--|--|--|
|1|数学|篮球|
|1|数学|羽毛球|
|1|英语|篮球|
|1|英语|羽毛球|

在该表中，候选键为`(学生编号,选课,爱好)`，即全部属性都是主属性，且不存在函数依赖，所以它是满足BNCF。

但是由于`学生编号`与`选课`之间，`学生编号`与`爱好`之间分别存在多值依赖，且`选课`和`爱好`之间没有任何关系，所以这里存在数据冗余。每多一个选课都要添加2条记录（篮球和羽毛球）。

4NF的目的就是为了消除这种数据冗余，即**消除**关系中的**多对多**关系，将其**拆分为**多个**一对多**关系。

我们将上表拆分成两张表：
- `S_C(StudentId,Course)`
- `S_H(StudentId,Hobby)`
  
#### 第五范式（5NF）

- 定义：在4NF基础上，处理半依赖和连接依赖。
- 目的：保证数据表中没有隐含的依赖关系。

在4NF的例子中，如果补充一点约束：只有爱好为篮球的学生才可以选择数学和语文，只有爱好为羽毛球的学生才可以选择英语和化学。

此时学生编号、爱好和选课三个属性之间任意两个属性都存在多值约束，此时这三个属性就变成了连接依赖，不存在多值依赖，也就自然满足了4NF，而在4NF基础上，进一步消除其不由候选码隐含的连接依赖，就得到了5NF。

**消除其不由候选码隐含的连接依赖**：保证不存在任何依赖属性不为候选码的连接依赖。

例如上面所述的关系中，候选码是(学生编号，选课，爱好)，而在其连接依赖中：
- 学生编号->选课和学生编号->爱好之间的连接属性为学生编号；
- 爱好->选课和学生编号->爱好之间的连接属性为爱好；
- 爱好->选课和学生编号->选课之间的连接属性为选课；

可见它们的连接属性都不是候选码，所以不满足5NF。

为了使其满足5NF，我们需要针对其连接依赖进行拆分：
- R1(学生编号,选课)。
- R2(学生编号,爱好)和R3(选课,爱好)。

#### 总结

|范式|解析|
|--|--|
|1NF|每一列都不可分割|
|2NF|消除**部分依赖**|
|3NF|消除**传递依赖**|
|BCNF|消除**主属性**对码的**部分依赖**和**传递依赖**|
|4NF|消除**多值依赖**|


### 五、反规范化

在关系模式的**规范化**过程中，会导致**关系**的概念越来越**单一化**，在响应用户查询时，往往需要涉及**多表**的**连接**操作，导致查询**性能下降**。

为此需要对关系模式进行修正，对部分影响性能的关系模式进行处理。包括分解、合并、增加冗余属性等。这种修正称为反规范化设计。

反规范化设计通过有意地违反数据库设计中的范式原则，将**数据冗余**存储在多个表中，通过**减少**表之间的**连接**来提高查询性能。

反规范化设计不应与从未进行过标准化的数据库相混淆。常见的反规范化操作有：
- 列：
  - **冗余列**：在多个表中存储相同的列，以避免连接操作。
  - **派生列**：将需要计算的列存储在表中，以避免计算开销。
- 表：
  - **表重组**：将多个表合并成一个表，以减少连接操作。
  - **表分割**：
    - 水平分割
    - 垂直分割

#### 总结
- 冗余**相同列**，派生**计算列**，减少连接与计算。
- 眼光从列放到表:
  - **表多**可合并**重组**。
  - **量多**可行列**分割**。
    - 行分割分维度分压力，
    - 列分割列主码分不同。
  

反规范化设计会在数据库中形成数据冗余，为解决**数据冗余**带来的**数据不一致**问题，设计人员往往需要采用**额外数据同步**的方法来解决数据不一致性。常见的方法有：

  - 事务控制：通过事务机制确保数据修改操作的原子性、一致性、隔离性和永久性。
  - 定期批量处理同步：通过定时批处理程序定时将相关表的冗余数据进行更新，确保数据一致性。
  - 触发器同步：是指在数据修改操作发生时自动触发响应的更新操作，保持数据一致性。


#### 冗余列

#### 派生列

#### 表重组

#### 表分割

表分隔是指将一个大表根据某些特定条件分隔成多个小表。每个小表只包含部分数据，但这些小表共同构成原来的大表。

这种方法可以有效地利用分布式数据库系统的特性，通过将数据分布在不同的服务器上，可以显著地提高查询性能和数据处理能力。

##### 水平分割

水平分割是根据数据行的特点进行分割，分割之后所得的所有表的结构都相同，而存储的数据不同。

例如我国的身份证号码若放在一个表中，由于我国人口众多，因此数据量很大，进行身份查询的效率会很低。这是可以按省份对它进行水平分割，把不同区域的身份信息存储在不同的表中，查询时只需根据省份代码查询相应的表，显著提高查询效率。

水平分割会增加应用的复杂度，特别是汇总数据时需要从不同的表或库中合并。有时候这种复杂性会超过它所带来的有点因此，综合考量表中数据具备很好的独立性时，就适合采用这种办法。

##### 垂直分割

垂直分割是根据数据列的特点进行分割，分割之后所得的所有表都含有主码列外其余列都不相同。

一般在一个表中某些列常用，而某些列不常用时采取垂直分割，把常用列和不常用列分开存储，从而提高查询效率。自然其缺点是若需汇总数据，则需要使用类似join的操作进行合并。


## 6.系统架构设计基础知识
### 6.1 软件架构设计的概念及生命周期
软件架构设计是指通过一系列的设计活动，获得满足系统 功能性需求，符合 **一定非功能性需求** 与 质量属性有相似含义的系统框架模型。

*ps：在架构设计中，主要考虑非功能性需求。*

软件架构设计的 **经验总结** 和 **重用** 是软件工程的重要目标之一。所采用的手段：
- 体系结构风格（*也就是 软件架构风格*）
- DSSA（*特定领域的软件架构*）

#### 软件架构设计的生命周期

> 口诀： 需计时、走不开

|阶段|要点|解释|
|-|-|-|
|需求分析|将需求模型 转换 软件架构模型；保证转换的可追踪性|用例模型 -> 功能模型|
|设计阶段|架构模型的描述、设计与分析、经验总结与复用|软件架构的基本概念、体系结构描述语言（*ADL*）、架构模型的多视图表示（*4+1视图*）|
|实现阶段|基于架构的开发支持、实现途径、测试技术||
|构件组装阶段|组装过程要考虑**失配**问题|1.构件失配；2.连接件适配；3.全局体系架构的冲突引起的失配|
|部署阶段|软硬件模型、部署方案||
|后开发阶段|软件部署之后的维护、演化、复用|动态软件体系结构、体系结构的恢复与重建|

> - ADL: Architecture Description Language

##### 4+1视图
架构设计阶段，以不同视角和视图来标识架构模型的用图，以 场景为核心，环绕逻辑视图、开发视图、进程视图、物理视图。

> 口诀： 挪开、你进场

### 6.2 基于架构的软件开发方法（ABSD）
ABSD方法是以构成软件的**体系结构来驱动**整个软件的开发过程。

体系结构的组成：
- **商业**（*商业需求，降低成本、提高效率、增加竞争力*）
- **质量**（*质量需求，如性能、可用性、安全性、可修改性*）
- **功能需求**

在ABSD中，用 **视角与视图** 描述软件架构、用 **质量场景** 来描述质量需求、用 **用例** 来描述功能需求。

ABSD是一个 **自顶向下**、**递归细化**的方法，软件的体系结构通过该方法得到细化，直到能产生 构件 和 类。

ABSD有三个基础：
1. 系统功能的分解。
   - 使用已有的基于模块的内聚和耦合技术
2. 架构风格的选择。
   - 选择合适的架构风格实现质量和商业需求
3. 强调软件模板的使用。

采用ABSD方法，设计活动可以从 项目总体功能框架明确后 就开始，因此该方法特别适用于：开发一些不能预先决定所有需求的软件系统，如产品线系统、长生命周期系统，也可为需求不能在短时间内明确的软件项目提供指导。


#### ABSD的过程

> 口诀：需记文、复誓言

|过程|要点|输出|
|-|-|-|
|体系结构需求|需求获取（*类似的从需求库取*）、标识构件（*类图、类分组、类打包成构件*）、需求评审|需求规格说明书（SRS）|
|体系结构设计|架构模型、构件映射、构件作用分析、设计评审|产生架构|
|体系结构文档化|使用者角度、分发所有开发、保持最新|**架构（体系结构）规格说明**、测试架构需求的**质量设计说明书**|
|体系结构复审|主要由外部人员复审，发现潜在的风险和错误||
|体系结构实现|用实体显示出架构|分析与设计、构件实现、构件组装、系统测试|
|体系结构演化|对架构进行改变、按需增删架构，使架构可复用|需求变化、架构演化计划、构件变动、更新后构件的相互作用、重新组装与测试、评审、演化后的架构|


### 6.3 架构风格
软件架构风格是描述某一特定领域中**系统组织方式**的**惯用模式**。

软件架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。

> 这里的**语义特性**是指：架构风格所包含的领域特定的含义、交互规则和行为约束。

#### 主要特征（架构定义、架构词汇表、架构约束）
架构风格定义了一类架构所共有的特征，主要包括：
- 架构定义
- 架构**词汇表**
- 架构**约束**
  

##### 架构定义
...

##### 架构词汇表
架构词汇表定义了架构中允许使用的组件类型（****）和连接器类型。

##### 架构约束
架构约束定义了组件和连接器之间的合法关系和行为规则。
- 组件约束：
  - 定义组件的行为和属性。例如，组件必须提供特定的接口，组件的状态必须满足某些条件等。
- 连接器约束：
  - 定义连接器的行为和属性。例如，连接器必须支持特定的通信协议，连接器的延迟必须在一定范围内等。
- 配置约束：
  - 定义组件和连接器之间的合法配置。例如，某些类型的组件只能通过特定类型的连接器通信，某些组件不能直接通信等。

##### 举例
1. 分层架构：
   - 词汇表：
     - 组件：`表示层`、`业务层`、`持久层`、`数据层`。
     - 连接器：`接口调用`、`数据库查询`。
   - 约束：
     - 组件约束：每一层只能与其相邻层通信，不能跳过中间层直接通信。
     - 连接器约束：表示层只能通过`接口调用`业务层，业务层只能通过接口调用持久层，持久层只能通过`数据库查询`数据层。
     - 配置约束：`表示层`不能直接访问`数据层`，必须通过`业务层`和`持久层`。

2. 事件驱动架构：
   - 词汇表：
     - 组件：`事件生产者`、`事件处理器`。
     - 连接器：`事件队列`、`事件通道`。
   - 约束：
     - 组件约束：`事件生产者`负责生成事件，`事件处理器`负责处理事件。
     - 连接器约束：`事件队列`负责接收和存储事件，`事件通道`负责分发传输事件到`事件处理器`。
     - 配置约束：`事件生产者`通过`事件队列`、`事件通道`与`事件处理器`通信，不能直接调用。

3. 微服务架构：
   - 词汇表：
     - 组件：独立的`服务`。
     - 连接器：`HTTP/REST`、`消息队列`
   - 约束：
     - 组件约束：每个`服务`必须是独立部署的单元，每个服务负责一个特定的业务功能。
     - 连接器约束：`服务`之间通过`HTTP/REST`或`消息队列`进行通信，通信协议必须标准化。
     - 配置约束：`服务`之间必须松耦合，`服务`的变更不应影响其他服务的正常运行。

#### 数据流风格
数据流风格是以数据驱动的架构风格，数据结构是流式数据，强调步骤顺序，以顺序结构或优先的循环进行交互。

1. 批处理风格。
   - 构件：独立的应用程序
   - 连接器：某种媒介，如磁带
2. 管道-过滤器风格。
   - 构件：过滤器
   - 连接器：管道

#### 调用/返回风格
1. 主程序/子程序风格。（*单线程控制，把问题划分若干步骤*）
   - 构件：主程序、子程序
   - 连接器：过程调用（*交互机制*）
2. 面向对象风格。（*数据抽象和面向对象*）
   - 构件：对象
   - 连接器：方法调用、接口调用、消息传递
3. 层次风格。（*系统被组织为多个层级，每层最多影响相邻的两层，通过严格的层级间交互规则连接*）
   - 构件：层级
   - 连接器：层级接口、交互协议
4. 客户端/服务器风格（C/S）。
   - 2层C/S：胖客户机、瘦服务端
   - 3层C/S：瘦客户机，应用逻辑在服务器上（表示层、功能层、数据层）
   - 构件：客户端、服务器
   - 连接器：网络通信、服务协议（SOAP、Restful）、远程过程调用（RPC）

> 请注意：**消息传递**作为连接器，在不同的架构风格中表示着不同的意义，大体要从意图、抽象程度和实现机制来区分
> - 面向对象风格的消息传递：实际上指的是对象间的交互请求，实现方式如方法调用和事件委托（*本质也是方法调用吧?*）
> - 进程通信风格的消息的传递：其消息如字节流形式的物理数据，传递的实现是依赖跨进程或网络传输


#### 仓库风格（以数据为中心）
仓库风格以 **中央数据存储** 为核心，构件通过 **共享数据仓库** 交互。

1. 数据库风格。
   - 构件：数据库（*中央数据结构*）
   - 连接器：SQL、存储过程
2. 黑板风格。（*协作式问题求解架构，适用于非确定性、多领域复合问题如语音识别*）
   - 构件：知识源（*独立的专家模块，每个负责解决特定子问题*）、黑板数据结构（*中央共享数据存储，保存问题的当前状态、中间假设和最终解*）、控制器（*执行顺序和优先级*）
   - 连接器：数据读写接口、事件通知机制
3. 超文本

#### 独立构件风格
系统中每个构件都是独立个体，它们之间不直接通信，以降低耦合，提高灵活性。

1. 进程通信风格。
   - 构件：独立的进程
   - 连接器：消息传递（点到点、同步/异步、远程过程调用）
2. 事件驱动风格。（*隐式调用思想，触发或广播事件，从而使注册事件的构建进行工作*）
   - 构件：事件生产者、事件处理器
   - 连接器：事件队列（*发布订阅*）、事件通道、回调机制（*监听*）

#### 虚拟机风格
虚拟机风格的基本思想是人为构建一个运行环境隔离底层硬件或平台差异，解析和运行**自定义**的指令或规则。

1. 解释器风格
   - 构件：解释引擎、被解释的源程序、被解释的代码存储区、解释引擎的当前状态记录区
   - 连接器：指令分发、回调钩子
2. 规则系统
   - 构件：规则库（*知识库*）、规则解释器、选择器（规则/数据）、工作内存（*提出的问题、解释的中间过程、结果等*）
   - 连接器：规则匹配、事件触发（*比如工作内存的数据变动*）


##### 基于规则的系统
基于规则系统的整体流程为7步：

|步骤|描述|
|---|---|
|1|需求分析|
|2|规则定义|
|3|规则引擎选择|
|4|规则存储与检索|
|5|规则执行|
|6|规则更新与维护|
|7|性能评估与优化|

（1）需求分析

在这一步需要明确系统需要实现的功能和规则。例如，一个贷款审批系统需要根据申请人的年龄、收入、信用记录等条件来判断是否批准贷款。

（2）规则定义

定义规则是实现基于规则系统的关键。规则通常以 `如果…那么…` 的形式表达。例如：

```
if age > 18 and income > 30000 and credit_score > 700:
  approve_loan()
```

（3）规则引擎选择

选择一个合适的规则引擎对于实现基于规则的系统至关重要。常见的规则引擎有Drools、Jess等。

（4）规则存储与检索

规则需要存储在某种形式的存储系统中，如数据库或文件系统。以下是一个简单的规则存储示例：

```json
rules = [
  {
    "condition": "age > 18", 
    "action": "approve_loan"
  }
]
```

（5）规则执行

在这一步，我们需要编写代码来执行定义好的规则。以下是一个简单的规则执行示例：

```
def execute_rules(person):
  for rule in rules:
    if eval (rule["condition"]):
      eval (rule["action"])
```


（6）规则更新与维护

（7）规则评估与优化

#### 环路控制风格（闭环风格）
环路控制风格在软、硬件之间存在一种反馈循环，从而将被控量维持在一个设定点。

- 构件：
  - 传感器：采集环境数据或输入数据
  - 控制器：根据采集数据和设定点进行控制。
  - 执行器：执行控制器的输出动作，改变系统状态
  - 反馈通道：将执行结果反馈给传感器与控制器，形成闭环。
- 连接器：
  - 反馈回路
  - 事件触发器
  - 数据流管道

闭环风格的典型案例是：空调恒温系统、汽车自适应巡航。

#### 架构风格一览表

|架构风格|要点|优点|缺点|典型实例|
|-|-|-|-|-|
|数据流风格|每个阶段的结果是下一阶段的输入|1.高内聚、低耦合（*同时衍生出良好的重用性、维护性、隐蔽性*）；2.可拓展性|1.交互性差；2.复杂性高；|传统编译器、网络报文处理|
||以整体的方式传递，一步接一步|||批处理|
||步骤通过数据流链接，每个处理步骤由过滤器实现，处理步骤间的数据传输由管道负责|2.管道过滤器风格支持并行|3.性能差（*每个过滤器需要解析与合成数据*）|管道-过滤器|
|调用/返回风格（*显示调用*）|采用调用-返回机制|1.良好的重用性（*接口不变就能复用*）；2.可维护性好；3.可拓展性好|分层很难（*1.并不是每个系统都能分层；2.对层进行抽象的方法难找；3.耦合性高的系统分层困难*）||
||显示的函数调用|||主程序/子程序风格|
||对象是构件，连接件是接口、封装的方法|||面向对象风格|
||OSI-7层模型，各层次间通过协议连接，每层最多影响上、下两层|||层次风格|
||服务调用|||C/S架构|
|独立构件风格|进程通信风格、事件驱动风格（*隐式调用*）|1.松耦合。2.良好的复用性/可修改性/可拓展性|1.构件放弃了对系统计算的控制。2.数据交换问题。||
||进程间独立的消息传递，可同步、异步|||进程通信风格|
||隐式调用，通过事件触发。||3.过程的语义必须依赖被触发事件的上下文约束，正确性的推理存在问题（?）|事件驱动风格|
|虚拟机风格|在自建环境上解析和运行自定义的规则|灵活应对自定义场景|复杂度高||
||适用于自定义规则的场合|高级语言解释引擎||解释器风格|
||规则为中心的风格在解释器基础上增加经验规则|决策支持系统、专家系统、人工智能||基于规则的风格|
|仓库风格（以数据为中心）|数据共享||||
||现代编译器的集成开发环境（IDE）、数据库系统|||仓库风格|
||黑板+知识源+控制，知识源的执行顺序不确定，由黑板当前问题（*状态*）和中间结果决定|语音识别、问题求解||黑板风格|
|||||超文本|
|闭环结构（*过程控制*）|软、硬件之间存在一个反馈循环。反馈循环接受一定输入，确定一定输出，再达到一个新的状态|||空调恒温机制、汽车定速巡航|
|C2风格|通过 连接件 绑定而运作的并行 构件 网络|||插件系统|
|MDA风格|模型驱动，CIM->PIM->PSM->可执行代码||||

> - 优点 主要以 性能、复用性、拓展性、可维护性等方面考量
> - 缺点 从 易用性、复杂性方面考量。
> - C2：构件（Component）、连接件（Connector）
> - MDA：Model-Driven Architecture，模型驱动架构
> - CIM: Computation-Independent Model，计算无关模型
> - PIM: Platform-Independent model，平台无关模型
> - PSM: Platform-Specific Model，平台相关模型

### 6.4 特定领域软件架构（DSSA）

> DSSA: Domain-Specific Software Architecture

#### 概念及特点
DSSA是指在一个 **特定领域** 中为 一组应用 提供 组织结构参考 的 **标准软件框架**，用以支持多个应用的生成。

这里的组织结构参考是指：
- **领域参考模型**
  - 高层次的抽象模型，描述该领域的关键概念及其关系，以帮助开发团队准确理解需求。
  - 比如：在医疗信息领域中，参考模型可能会定义病人、医生、治疗、药物、诊断等实体及其相互作用。
- **参考需求**
  - 基于领域参考模型定义的，描述系统需要满足的功能性和非功能性需求
  - 比如：高可用性、数据隐私、界面易用性等
- **参考架构**
  - 基于 领域参考模型和参考需求 后定义或参考的软件架构，通常包括架构组成、技术选型、设计模式
  - 比如：采用微服务架构、使用加密技术、使用特定中间件和数据库。

综上，DSSA的特点如下：
1. 特定领域
2. 标准化
3. 可复用：（*标准架构是在能复用的原理上建立的*）
4. 灵活性（*可拓展*）：（*在标准架构大多数是个半成品，可以自己灵活拓展变成成品*）

#### DSSA的基本活动
1. 领域分析：获取领域模型。
   - 领域模型描述领域中系统之间的共同需求。
2. 领域设计：获取DSSA
   - 说白了就是获取（*能够适应领域模型中的需求的*）框架
3. 领域实现
   - 依据领域模型和DSSA进 开发和组织可重用信息，对基础软件架构进行实现

> 口诀：套用软件架构设计的生命周期口诀 - 需计时
> - 需：在生命周期中是指架构需求分析，在这里套用过来衍为 领域分析。

#### DSSA的参与人员
（分析师 + 设计师 + 实现人员） + 领域专家

> 口诀：需计时 + 专家

|人员|要求|主要任务|
|-|-|-|
|**领域专家**|有经验的、参与需求分析、设计、实现、有项目管理经验的软件工程师|包括提供：该领域中的**需求规约**和**实现的知识**。|
|领域分析师|具有知识背景的、有经验的系统分析师|分析 + 知识获取 => 领域模型|
|领域设计师|有经验的软件设计人员|领域模型 + 现有系统 => DSSA，并对DSSA的准确性和一致性进行验证|
|领域实现人员|有开发经验的程序人员来担任|领域模型 + DSSA => 构件|

#### DSSA的建立过程（Δ）
DSSA的建立过程有5个阶段，每个阶段又分成子阶段和步骤，是一个 **并发的**、**递归的**、**反复的**、**螺旋的**过程。

|阶段|要点|
|-|-|
|定义领域范围|需要满足的需求|
|定义领域特定元素|领域字典、领域术语的同义词词典|
|定义领域特定的设计和约束||
|定义领域模型和架构||
|收集/生产**可重用的产品单元**||

> 口诀：范元素使 设计了一个魔法架构 生产单元产品

#### DSSA的三层模型

![DSSA的三层模型](https://sustamp.github.io/assets/pictures/ruankao/DSSA-Hierarchy.png)

1. **领域开发环境**：*关注领域知识的获取和建模。*
   - 领域分析：识别领域中的关键概念、实体和关系。
   - 领域建模：将领域知识形式化为模型，例如领域模型、领域模式等
   - 领域知识库：存储领域模型和模式，供后续开发使用。
2. **领域特定应用开发环境**：
   - 基于领域开发环境，配置和生成具体应用的架构和代码
3. **应用执行环境**
   - 运行特定领域应用的底层平台和基础设施，确保构件可部署和执行


### 6.5 构件与中间件技术
#### 构件的概念
定义1：
- 软件构件是一组组装单元，它具有 规范的接口 和 显式的语境依赖。可以被独立部署或由第三方任意组装。

定义2：
- 构件是某系统中 有价值的、几乎独立的、并可替换的 一个部分，它在良好定义的体系结构语境内 能满足某清晰的 功能。

定义3：
- 构件是一个可以独立发布的功能部件，能通过接口访问它的服务。


我们进一步区分一下模块、对象和构件：

||特性|
|-|-|
|模块|结构化开发的产物|
|对象|1.一个实例单元；2.封装了自己的状态和行为；3.可能具有状态（*外部可见*）|
|构件|1.独立部署单元；2.作为第三方的组装单元；3.没有外部可见的状态|

#### 构件的复用
构件复用的过程：

> 口诀：去、评理、改装

|过程|要点|示例|
|-|-|-|
|**1检索与提取构件**|*寻找需要的构件*||
||关键字检索|树形或有向无回路图结构|
||刻面检索|利用facet描述构件的应用领域、使用环境、功能或其他特征|
||超文本检索|模糊查询相关概念的构件|
|**2理解和评价构件**|*复用构件的前提：理解这个构件的用途、评价这个构件是否满足需要*|构件库一般有规范的描述文档：构件功能与行为、相关的领域知识、可适应性的约束条件、可预见的修改及修改方式|
|**3修改构件**|理想构件能**拿来就用**，但实际都要基于原构件再开发||
|**4组装构件**|构件的组装方式，同时考虑失配问题|1.构件失配；2.连接子失配；3.全局体系结构的假设存在冲突的失配|
||基于功能的组装|采用子程序调用和参数传递的方式将构件组装起来|
||基于数据的组装|（*仍然是基于功能组装的原理*），但不是依赖功能分解，而是面向数据的设计方法，如Jackson系统开发方法|
||基于面向对象的组装|从类库中检索基类：1.若满足系统需求，直接用；2.不满足则生成子类来满足系统需求|

> 请注意：组装构件的3种方式 与 构件可独立部署 的特性相悖，独立部署是一种广义上的特性。

#### 中间件
中间件是一类特殊的构件

中间件的分类见1章节-计算机基础知识-中间件部分。



## 7.系统质量属性与架构评估
### 质量属性的概念
软件系统质量是指软件系统与 明确地定义 和 隐含地定义 的需求相一致的程度。

> - 明确地定义的需求：满足合同定义的、用户明确提出的需求，如基本功能
> - 隐含地定义的需求：用户没提出的、期望的或者意外的需求，如性能、可维护性、安全性
> - ps：说的很隐晦，向出教材的哪些人，献以我诚挚的问候！

系统质量属性是衡量软件 **非功能需求**的重要因素。

### 影响质量属性的因素

|质量特性（*功靠效用互益*）|质量子特性|
|-|-|
|**功能性（functionality）**|*准时用一安*|
||准确性（accuracy）|
||安全性（security）|
||适宜性（suitability）|
||互用型（interoperability）|
||依从性（compliance）|
|**可靠性（reliability）**|*成错付*|
||成熟性（maturity）|
||容错性（fault tolerance）（*错误吞了*）|
||可恢复性（recoverability）|
|**可用性（usability）**|*学姐坐*|
||可理解性（understandability）|
||可操作性（operability）|
||易学性（learnability）|
|**效率（efficiency）**|*原石*|
||时间特性（time behavior）|
||资源特性（resource behavior）|
|**可维护性（maintainability）**|*定分改测*|
||可分析性（analyzability）|
||可修改性（changeability）|
||稳定性（stability）|
||可测试性（testablity）|
|**可移植性（portability）**|*应装一提*|
||适应性（adaptablity）|
||易安装性（installability）|
||一致性（conformance）|
||可替换性（replaceability）|

> 这些概念可能与以往的经验或认知不符，谨慎对待。

影响软件质量的3组因素：
1. 产品运行
   - 准确性
   - 可用性
   - 效率（*性能*）
   - 安全性
   - 健壮行
   - 风险
2. 产品修改
   - 可理解性
   - 可修改性
   - 灵活性
   - 可测试性
3. 产品转移
   - 可移植性
   - 可再用性（*复用性*）
   - 互运行性（*与其他系统结合使用*）

### 质量属性场景
质量属性场景是 描述质量属性的手段。它是一个具体的 质量属性要求，是利益相关者与系统交互的简短陈述。

质量属性场景主要有6大类：
1. 可用性 质量属性场景
2. 可修改性 质量属性场景
3. 性能 质量属性场景
4. 可测试性 质量属性场景
5. 易用性 质量属性场景
6. 安全性 质量属性场景

质量属性场景的描述内容有6个组成部分：

|场景要素|可能的情况|
|-|-|
|刺激源|造成刺激的实体，如人为的、其他情况的|
|刺激|造成系统使用出现的情况|
|环境|刺激发生的环境|
|制品|被刺激的系统或系统的一部分|
|响应|制品在受刺激后做出的反应或行动|
|响应度量|对响应的行为进行度量|


### 系统架构评估的重要概念
正确识别敏感点、权衡点、风险点和非风险点是进行软件架构评估的关键步骤。

#### 敏感点（Sensitive Point）
敏感点是指 实现 （一个特定质量属性的）**关键特征**，该特征为 （一个或多个构件） 所共有。

研究敏感点可以帮助设计师 在实现系统质量目标时 识别出关键问题。

例如：
1. 加密算法对安全性是敏感点
2. 缓存策略对性能是敏感点

#### 权衡点（Tradeoff Point）
权衡点是指 （*会影响多个质量属性的*） 决策点。调整一个质量属性可能会影响拎一个质量属性。

例如：
1. 改变加密级别会对提高安全性，但性能会下降。如果系统对服务的时间有严格限制，那么加密级别会成为权衡点
2. 提高刷新频率会是热点数据更新及时，但会增加系统负载。如果系统负载要求高，那么刷新频率就会成为权衡点


#### 风险承担者（利益相关人）（Stakeholders）
系统的架构会涉及许多人的利益需求，这些人对架构施加影响，以保证自己的目标能够实现。

##### 风险点/非风险点
由风险承担着可以衍生出 风险点 和 非风险点 的概念。

- 风险点：系统会存在的隐患 或瓶颈。
- 非风险点：系统虽然有风险（*比如响应时间较慢*），但能接受。


### 系统架构评估方法
#### 软件架构分析法（SAAM）

> SAAM: Software Architecture Analysis Method / Scenarios-based Architecture Analysis Method （基于场景的架构分析法）

关注可修改性、可移植性、可扩充性。

- 主要输入：问题描述、需求说明、架构描述文档。（*侧重要表述的东西*）
- 主要活动：场景开发、架构描述、单个场景开发、场景交互、总体评价

#### 架构权衡分析法（ATAM）

> ATAM: Architecture Tradeoff Analysis Method

由SAAM发展而来，主要针对性能、实用性、安全性、可修改性。

ATAM 分为4个主要活动：
1. 场景和需求收集
2. 架构视图和场景实现
3. 属性模型构造和分析
4. **折中**

ATAM 采用 **效用树（Utility Tree）** 工具对 质量属性 进行 **分类和优先级排序**。效用树的结构包括：
- 树根 ——> 质量属性 ——> 属性分类 ——> 质量属性场景（*叶子节点*）



#### 成本效益分析法（CBAM）

> CBAM: Cost-Benefit Analysis Method

在ATAM基础上建立软件的 **经济** 模型。


## 8.软件可靠性技术
### 可靠性与可用性的区别

|质量属性|定义|
|-|-|
|可靠性|软件系统在（应用或系统）**错误**、**意外**、**错误使用** 的情况下维持系统的功能的能力|
|可用性|系统能够 **正常运行的时间比例**|

软件可靠性 != 硬件可靠性，为什么？
1. 复杂性：软件复杂性更高，大部分失效来自软件。
2. 没有物理退化：硬件有物理退化的过程，软件没有
3. 唯一性：软件的每个COPY版本都一样，而两个硬件不一样。
4. 版本更新快：软件的的版本更新快


### 可靠性指标

|指标|描述|
|-|-|
|MTTF|平均无故障时间|
|MTTR|平均故障修复时间|
|MTBF|故障间隔时间|
|系统可用性|MTTF / (MTTR + MTTF) * 100%|

> - MTTF: Mean Time To Failures
> - MTTR: Mean Time To Repair
> - MTBF: Mean Time Between Failures

### 可靠性设计技术

1. 避错技术。
2. 降低复杂度技术。
3. **检错技术**。
   - 出错报警、人工处理。（*成本较低*）
4. **容错技术**。
   - N版本程序设计（*静态冗余*）
   - 恢复块设计（*动态冗余*）
   - 防卫式程序设计
   - 结构冗余（*硬件冗余、软件冗余*）
   - 信息冗余（*校验码*）
   - 时间冗余（*重复进行多次相同的计算*）


#### N版本程序设计

#### 恢复块设计

#### 防卫式程序设计
对于程序中存在的错误和不一致性，通过在程序中包含 错误检查代码 和 错误恢复代码，使得错误一旦发生，程序能撤销错误状态，恢复到一个已知的正确状态中去。
- 实现策略：错误检测、破坏估计、错误修复

#### 双机容错
- 双机热备模式：主系统、备用系统
- 双机互备模式：同时提供不同的服务，心不跳则接管
- 双机双工模式：同时提供相同的服务，集群的一种

> 双机模式是集群的前身




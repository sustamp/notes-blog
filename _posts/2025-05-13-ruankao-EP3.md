---
# layout: post
layout: post-custom
title: "系统架构师笔记-EP3"
---

>**万时定律**，10000小时定律。  
简单来说，要成为某个领域顶尖的专业人才，需要10000小时持续不断的练习。例如小提琴、足球、国际象棋、围棋等领域，无一例外都遵循这个定律。  
技术人员的成长需要对技术的热情和持续不断学习，思考，实践和总结。

## 大纲及分集

<a href="https://sustamp.github.io/notes-blog/2025/03/20/ruankao-outline.html" target="_blank">架构设计师考试大纲</a>

<a href="https://sustamp.github.io/notes-blog/2024/10/31/ruankao-study-notes.html" target="_blank">系统架构师笔记-EP1</a>

<a href="https://sustamp.github.io/notes-blog/2025/05/09/ruankao-EP2.html" target="_blank">系统架构师笔记-EP2</a>

## 4.软件工程基础知识
### 4.1 软件工程
#### 4.1.1 软件工程概述
##### 软件工程的发展历程和软件危机
##### 软件工程的定义

#### 4.1.2 软件过程模型一览表

|模型|特征|
|-|-|
|瀑布模型|结构化方法。严格区分阶段（*上一个阶段的结果是下一个阶段的输入*），适合需求明确、文档齐全、风险控制弱的项目|
|原型模型|迭代法。适用于**需求不明确**的场合。有2个阶段：原型开发阶段（*模拟界面、类似软件、快速原型*），目标软件开发阶段（*根据原型理解需求后开发具体的目标软件*）|
|螺旋模型|迭代法。瀑布与原型（*演化*）结合体，强调**风险分析**。适用于大型、复杂、风险项目。|
|喷泉模型|面向对象方法。**复用好**、开发过程**无间隙**、节省时间|
|V模型|开发与测试（*验证*）相结合。主要内容是：1.测试分阶段：编码-单元测试（**扁担**）、详细设计-集成测试（**吉祥**）、概要设计-系统测试（**膝盖**）、需求分析-验收测试（**延续**），2.测试计划先行：详细设计阶段要做单元测试的计划、概要设计阶段要做集成测试的计划、需求分析阶段要做系统测试和验收测试的计划|
|变换模型|适用于形式化开发|
|智能模型|适用于基于规则的专家系统|
|快速应用开发（RAD）|基于构件的开发方法。当**模块化要求高**时 开发或复用构件、**用户参与**，不适用新技术。流程：业务建模、数据建模、过程建模、应用生成、测试与交付|
|统一软件开发过程（RUP/UP）|**用例驱动**、架构为中心、迭代、增量|
|敏捷模型|面向人的、适应性、迭代增量式开发过程|
|基于构件的开发模型（CBSD）|可重用构建模型。基于构件的开发方法，自主开发或复用构件。|
|基于构件的软件工程（CBSE）|CBSE体现**购买而不是重新构造**的哲学。可组装（*接口对接*）、可部署、文档化（*判断构件是否符合需求*）、独立性、标准化|
|逆袭工程||
|净室软件工程（CSE）||

> - UP：Unified Process，统一过程。
> - RUP：Rational Unified Process，是IBM Rational公司对UP的具体商业化实现，是一个详细的、可配置的软件开发流程框架。
> - RAD：Rapid Application Development，快速应用开发。
> - V模型：把 *V* 理解成：Validation，即验证。

#### 敏捷模型
##### 敏捷方法的主要特点
1. 敏捷方法是**适应性**（adaptive），而非预设型（predictive）。
2. 敏捷方法是**面向人的**（People-oriented），而非面向过程（Process-oriented）。
3. 迭代增量式的开发过程。（*小步快跑，很适合小型项目*）

敏捷开发要求 开发人员有权做技术方面的决定，强调 相关人员之间的信息交流，提倡 面对面交流。

##### 敏捷方法一览表

|方法|要点|
|-|-|
|XP|沟通、简单、反馈、勇气，近螺旋式开发方法|
|SCRUM|**侧重于项目管理**，划分成sprint，快速迭代，增量交付|
|水晶方法|提倡**机动性方法**，拥有对 不同类型项目 非常有效的敏捷过程|
|特征驱动开发方法（FDD）|迭代开发模型，认为有效软件开发需要3要素：人、过程、技术|
|开放式源码|其他方法强调人员集中地点办公，开放式源码的程序员**在地域上分布很广**|
|自适应软件开发（ASD）|核心：猜测、合作、学习，是3个非线性的、重叠的开发阶段|
|动态系统开发方法（DSDM）|倡导**以业务为核心**|

> - XP：Extreme Programming，极限编程。
> - FDD：Feature Driven Development，特征驱动开发。
> - ASD：Adaptive Software Development，自适应软件开发。
> - DSDM：Dynamic System Development Method，动态系统开发方法。

##### 敏捷方法-极限编程（XP）
极限编程（eXtreme Programming）是一种近螺旋式的开发方法，将复杂的开发过程分解为一个个相对比较简单的小周期。XP方法体现了4大价值观：
1. **沟通** —— *加强face to  face 交流*
2. **简单** —— *不过度设计*
3. 反馈 —— 及时反馈
4. 勇气 —— 接受变更的勇气

12条过程实践规则：
1. 简单设计
2. 测试驱动
3. 代码重构
4. 结对编程
5. 持续集成
6. 现场客户
7. 发行版本小型化
8. 系统隐喻
9. 代码集体所有制
10. 规划策略
11. 规范代码
12. 40小时工作机制

##### 敏捷方法-SCRUM
SCRUM侧重项目管理，是一个增量的、迭代的敏捷软件开发过程。

![敏捷方法-SCRUM](https://sustamp.github.io/assets/pictures/ruankao/AgileDevelopment-SCRUM.png)

关于SCRUM的过程，下面内容介绍的足够详细（*来自 51cto 考题*）：

Scrum敏捷开发中，项目团队由Scrum主管、产品负责人和开发团队人员三种不同的角色组成，其开发过程由若干个Sprint（短的迭代周期，通常为2到4周）活动组成。

Product Backlog是在Scrum过程初期产生的一个**按照商业价值排序的需求列表**，该列表条目的体现形式通常为用户故事。在每一个Sprint活动中，项目团队从Product Backlog中挑选**最高优先级的用户故事**进行开发。被挑选的用户故事在**Sprint计划会议**上经过细化分解为任务，同时初步估算每一个任务的预计完成时间，编写Sprint Backlog。

在Sprint活动期间，项目团队每天早晨需举行**每日站会**，重新估算剩余任务的预计完成时间，更新Sprint Backlog、Sprint燃尽图和Release燃尽图。在每个Sprint活动结束时，项目团队召开**评审会议**和**回顾会议**，**交付产品增量**，总结Sprint期间的工作情况和问题。此时，如果Product Backlog中还有**未完成的用户故事**，则项目团队将开始筹备**下一个Sprint活动迭代**。

##### 敏捷模型的最佳实践（论文？）

![敏捷方法-SCRUM](https://sustamp.github.io/assets/pictures/ruankao/AgileDevelopment-Practice.png)


#### 统一过程模型（RUP/UP）
##### RUP的核心概念和特点
##### RUP的生命周期
##### 4+1视图模型

#### 能力成熟度模型（CMMI）

> CMMI: Capability Maturity Model Integration

##### CMMI的等级、关键过程域和过程目标

> 口诀：初管 定 良优

|级别|要点|能力或目标|
|-|-|-|
|初始级|无序、混乱的，软件产品的成功依赖**个人**|目标：要具备基本管理，达到已管理级|
|已管理级|项目级控制。已建立**项目管理过程**|项目计划、跟踪管理、质量保证|
|已定义级|组织标准化。软件过程均已**文档化**、**标准化**|标准流程库（*如开发、测试、项目管理模板*）、流程可裁剪、风险管理|
|量化管理级|数据驱动。有详细的度量标准|关键过程有统计数据（*缺陷率、生产率*）、能预测和管理偏差、改进基于数据而非经验|
|优化级|持续改进，鼓励创新|主动识别和消除过程问题、引入新技术（*如AI*）、鼓励创新|


### 4.2 需求工程
#### 需求获取
#### 需求变更

### 4.3 系统分析与设计
#### 结构化分析
结构化分析是在系统分析阶段进行系统建模的过程，会建立以下3种模型：
- 数据模型：实体关系图（E-R图）
  - 包含数据元素和联系
- 逻辑模型：数据流图（DFD）
  - 数据流图包含了：外部实体、加工逻辑、数据流、数据存储
- 行为模型：状态转换图（STD）
  - 包含行为状态的变化过程
  
3种模型各自环抱，形成 数据字典 放在核心。

#### 结构化设计
##### 耦合
耦合表示模块间的联系程度。

以下是 模块间 耦合类型一览表：

> 口诀：非鼠标 可通宫内

|耦合类型|描述|举例|
|-|-|-|
|1.非直接耦合|模块间没有直接耦合关系，它们之间的联系完全是通过上层模块的控制和调用|两个完全独立的模块。（*现实中少见*）|
|2.数据耦合|模块间仅通过**参数传递**基本数据类型交互|`calculate(a, b)`，仅传入 int a, b。（*最佳实践，低耦合*）|
|3.标记耦合|模块间通过**复合数据结构**（如对象、结构体）交互，但仅使用部分字段|`updateUser(user)`，但只修改 user.name。（*稍高耦合，注意数据冗余*）|
|4.控制耦合|一个模块通过**控制信号**（如标志位）影响另一模块的逻辑|`process(data, is_urgent)`，is_urgent 控制流程。（*较高耦合、慎用*）|
|5.通信耦合|多个模块通过共享同一组输入或输出数据来间接交互|共享输入：如配置文件，共享输入：日志文件、消息队列。（*难维护，当共享源出问题，其他也会出问题*）|
|6.公共耦合|多个模块共享同一全局数据区（如公共内存、静态变量、通信区）|多个模块读写同一个缓存，`static List cache`。（*高耦合，调试困难*）|
|7.内容耦合|一个模块直接访问或修改另一模块的**内部数据**；一个模块有多个入口;两个模块间有重叠代码|模块A直接修改模块B的私有变量。（*最差实践，避免使用*）|

> 从上到下，耦合度逐渐增高。

##### 内聚
内聚表示模块内的元素之间的联系紧密程度。高内聚的模块应当恰好做目标单一的一个功能。

关于模块内的元素不同内聚类型，见下表：

> 口诀：工序 通过 是罗欧

|内聚类型|描述|举例|
|-|-|-|
|1.功能内聚|完成一个功能，各个部分协同工作，缺一不可||
|2.顺序内聚|模块内的处理步骤必须顺序执行，且前一步的输出是后一步的输入||
|3.通信内聚|模块内的功能元素通过操作同一组数据结构而结合在一起|读取学生成绩、处理学生成绩、存储学生成绩|
|4.过程内聚|模块内的功能元素按**特定的次序**执行，但步骤间可能无直接数据传递|验证订单、扣款、生成发票|
|5.时间内聚|模块内的功能元素在**同一时间段内被执行**，但逻辑上可能没有直接关系|初始化模块|
|6.逻辑内聚|模块内的功能元素基于某种逻辑条件选择性执行|错误处理模块、信息分发模块|
|7.偶然内聚|完成一组没有关系或松散关系的功能||

> 从上到下，内聚紧密程度逐渐降低。

##### 概要设计
概要设计的主要任务是 确定系统的结构，对系统进行 模块划分，确定每个模块的功能、接口和模块间调用关系。

输出：系统结构图

##### 详细设计
详细设计主要任务是 设计每个模块的实现细节。

详细设计的表示工具有：
- 图形工具（*表示过程细节*）
  - 业务流图、程度流程图、问题分析图（PAD：提供了5种控制结构，并允许递归调用）
- 表格工具
  - 用表格描述过程的细节，参数或条件
- 语言工具
  - 利用高级语言或伪代码

##### 结构化编程
结构化程序设计采用 自顶向下、逐步求精的设计方法，划分模块通过 顺序、选择（*分支*）、循环 的控制结构进行连接，并且只有一个入口一个出口。

结构化程序设计的原则可以归纳为 32个字：
- 自顶向下、逐步求精
- 清晰第一，效率第二
- 书写规范、缩进格式（???）
- 基本结构、组合而成

#### 面向对象分析

#### 面向对象设计


#### 4.3.1 结构化方法
#### 4.3.2 面向对象方法
#### 4.3.3 其他方法

### 4.4 软件测试
### 4.5 净室软件工程（CSE）
### 4.6 基于构件的软件工程（CBSE）
### 4.7 软件项目管理

## 5.数据库设计基础知识
### 一、基本术语

#### 属性（Attribute）
- 在现实世界中，要描述一个事务常常取若干特征来表示。这些特征称为属性。
- 例如学生通过学号、姓名、性别、系别、年龄、籍贯等属性来描述。
  

#### 域（Domain）
- 每个属性的取值范围对应一个值的集合，称为该属性的域。
- 例如，学号的域是6位整型数；姓名的域是10位字符；性别的域为{男，女}等。


#### 超键（Super Key）
- 超键是一组属性。能够唯一标识表中每一行记录。
- 超键可以包含多余属性，即便不是必须的，结合起来也可以唯一标识记录。


#### 候选键（Candidate Key）
- 候选码是最小的超键。即从超键中移除任何属性后，它就不再能唯一标识表中的每一行记录。


#### 主键（Primary Key）
- 若一个关系中有多个候选码，则选定其中一个作为主键。
- 主键也是最小的超键。一旦选定，应尽量避免更改。


#### 主属性（Prime Attribute）
- 包含在任何候选码中的属性称为主属性。


#### 非主属性（Non-Prime Attribute）
- 不包含在任何候选码中的属性称为非主属性。


#### 外键（Foreign Key）
- 如果关系模式R中的属性或属性组不是该关系的码，但它是其它关系的码，那么该属性集对关系模式R而言是外键。
- 例如，客户与贷款之间的借贷联系c_1(c_id,loan_no)，属性c_id是客户关系中的键，所以c_id是外键；属性loan_no是贷款关系中的键，所以loan_no也是外键。

#### 全码（All-Key）
- 关系模型的所有属性组是这个关系模式的候选码，称为全码。
- 例如，关系模式R(T,C,S)，属性T是教师，属性C是课程，属性S表示学生。假设一个教师可以讲授多门课程，某门课程可以由多个教师讲授，学生可以听不同教师讲授的不同课程，那么，要想区分关系中的每一个元组，这个关系模式R的码应为全属性T、C和S。

### 二、关系模式

数据库的关系模式是关系型数据库中用于描述**数据库结构**和**数据**之间**关系**的一种方式。

它是对数据库关系（表）的逻辑结构进行定义，形式化表示为：`R(U,D,dom,F)`。

形式化的表示可以帮助设计者规范地描述数据库中的数据结构，以及数据之间的逻辑关系。这有助于确保数据的完整性和准确性，并为数据库的查询和操作提供一个清晰的基础。

通常，可以将关系模式简记：`R(U)` 。

- R：表示关系的名称，代表数据库中的一张表或关系。
- U：表示关系R的属性集合。这些属性定义了关系中的列。
- D：表示属性集合U中每个属性的域或数据类型集合。域是对属性可能值的限制，确保每个属性的值都属于其指定的数据类型。
- dom：表示属性集合U中每个属性的值域，是属性到域的映像集合。
- F：表示关系R的函数依赖集合。

举个例子，假设我们有一张`学生成绩表`，存储的是学生信息和他们的成绩。用关系模式`R(U,D,dom,F)`来描述，其中：
- R：学生成绩
- U：{学号，姓名，课程，成绩}
- D：{整数，字符串，字符串，浮点数}
- dom：
    - 成绩：分数，例如90.5
    - 课程：课程名称，例如数学
    - 姓名：学生的名称，例如张三
    - 学号：具有唯一性的studentId，例如123456
- F：{学号->姓名，（学号，课程）->成绩}
  
以上关系模式，可以简记为：`学生成绩(学号，姓名，课程，成绩)`

### 三、数据依赖

#### 函数依赖

在上述关系模式的说明中，我们提到了函数依赖F，数据库中的函数依赖是描述关系型数据库中表的**属性之间**相互依赖**关系**的概念。

它反映了表中数据属性之间的逻辑关系，即一个属性或属性集是否能够决定另一个属性或属性集的值。

假设现有如下关系模式`学生表`：

|学号|姓名|专业名|性别|出生日期|本学期学分|
|-|-|-|-|-|-|
|42014601|李梦|信管|女|2000-02-11|24|
|42014602|冯小羽|电商|男|2001-08-07|24|
|42014603|朱秀淳|财会|女|2001-09-07|24|
|42014604|曾敏能|物流|男|2001-10-18|24|

`学生成绩表`：

|学号|姓名|课程号|成绩|
|-|-|-|-|
|42014601|李梦|020114|100|

##### 平凡函数依赖
- 定义：设一个关系`R(U)`，`X`和`Y`为属性集U的一个子集，当X->Y时，如果Y ⊂ X，那么称：`X->Y`为**平凡函数依赖**。
- 例如：`(学号，姓名) -> 姓名`。

##### 非平凡函数依赖
- 定义：设一个关系`R(U)`，`X`和`Y`为属性集U的一个子集，若X->Y时，Y ⊄ X，那么称：`X->Y`为**非平凡函数依赖**。
- 举例：`(学号， 课程号) -> 成绩` 。

##### 完全函数依赖
- 定义：在`R(U)`中，X、Y为U的子集，若X->Y，且对X的任意一个**真子集Z**来说，Z->Y都不成立。那么称：`X->Y`为**完全函数依赖**。
- 举例：`(学号， 课程号) -> 成绩`。

*(学号，课程) -> 成绩。学号和课程单独拿出来都不能决定成绩。所以说 `成绩` 完全依赖于 `(学号，课程)`。*


##### 部分函数依赖
- 定义：在`R(U)`中，X、Y为U的子集，若X->Y，存在一个X的**真子集Z**，使得Z->Y，那么`X->Y`为**部分函数依赖**。
- 举例：`(学号，课程号) -> 姓名`

##### 传递函数依赖
- 定义： 在一个关系模式`R(U)`中，X、Y、Z为属性集U上的子集，如果X->Y，Y不能反推出X，且Y->Z，这时候X也可以推出Z，即 `X -> Y -> Z`，则`X->Z`为**传递函数依赖**。
- 举例：`学号 -> 班级`，`班级 -> 班主任`，所以`学号 -> 班主任`为传递函数依赖。

资料： [快速理解数据库函数依赖](https://blog.csdn.net/weixin_62714329/article/details/129806085)

##### 多值依赖
定义：
- 存在关系模式`R(U)`，X、Y、Z是U的子集，并且 Z = U-X-Y。
- **当前仅当**对R(U)的任一关系r，给定的一堆`(x,z)`值，有一组`y`的值，这组值仅仅决定于`x`的值而与`z`值无关。则**多值依赖** X->Y成立，

举例：  

`学生选课表(学号，专业，课程)`中，假设每个专业有多个学生，有一组必修课，设同专业内所有学生选修的必修课相同。

按照语义，给定一堆`(专业, 课程)`的值，有一组`(学号)`的值仅仅决定于`专业`，与`课程`无关。则称`专业->学号`是**多值依赖**。简单理解就是**一对多**关系(1:n)。

**其实还有一个方法可以判断是否存在多值依赖**

- 找到`专业`属性M的**相同**值和`学号`属性S的**不同**值的任意两个元组，**交换**他们的`课程`C值。
- 重新组成的元组如果可以在这个表内找到，那么就存在多值依赖。

##### 连接依赖

一个关系模式(表)`R(U)`可以分解为几个子表`R(A)`,`R(B)`，如果将几个子表连接起来以后仍然是原来那个表`R(U)`。则称原来的那些属性之间具备``连接依赖``。


### 四、规范化

数据库设计规范化（Database Nomalization）是数据库设计中的一个重要方法，旨在优化数据库结构：
- 提高数据的**一致性**和**完整性**。
- **减少**数据**冗余**。
- 增强数据**修改**的**灵活**性。
- **降低**数据**查询的复杂性**。
  
规范化通常涉及将**大表**拆分为更小、更专门的**小表**，并通过定义**表之间**的**关系**来**连接**这些表。

通常可以通过判断分解后的模式达到几范式来评价模式规范化的程度。范式从低到高依次为：

1. 第一范式（1NF）
2. 第二范式（2NF）
3. 第三范式（3NF）
4. 巴斯-科恩范式（BCNF）
5. 第四范式（4NF）
6. 第五范式（5NF）
7. 第六范式（6NF）

在实际应用中，**3NF**已经足够满足大多数数据库设计的需求。

#### 第一范式（1NF）

- 定义： 数据表中的每一列都是**不可分隔**的数据项，不包含重复列。
- 目的： 消除重复数据，确保每个字段都是原子性，减少数据冗余。

若存在学生表如下：

|学号|姓名|课程|
|--|--|--|
|1|Alice|Math,English|
|2|Bob|Math,Science|
|3|Charlie|Art,History|

Courses是学生所选的所有课程，这种表设计使得查询某课程被哪些学生选择变得复杂，并且在新增课程、取消选课时也要分解Courses字段才能进行处理。

#### 第二范式（2NF）

- 定义： 在1NF的基础上，**非主键**列**完全依赖**于**主键**，而不是主键的一部分。
- 目的： 消除**部分函数依赖**，进一步减少数据冗余。

例如供应商和它所提供的零件信息，关系模式和函数依赖集F如下：
- 供应商信息表`Supplier(Sno, Sname, Status, City, Pno, Qty)`
- 函数依赖F = {`Sno->Sname`, `Sno->Status`,`Status->city`, `(Sno,Pno)->Qty`}

具体关系如下表所示:

|Sno|Sname|Status|City|Pno|Qty|
|--|--|--|--|--|--|
|S1|精益|20|天津|P1|200|
|S1|精益|20|天津|P2|300|
|S1|精益|20|天津|P3|480|
|S2|盛锡|10|北京|P3|500|
|S3|东方红|30|北京|P2|280|
|...|...|...|...|...|...|


分析：
- 每列都是不可再分的数据项，满足1NF。
- 函数依赖：
  - `Sno -> Sname`, 
  - `Sno -> Status`, 
  - `Status -> city`, 
  - `(Sno,Pno)-> Qty`
- 候选键：
  - `(Sno, Pno)`

存在部分函数依赖：`(Sno, Pno) -> (Sname, Status)`。

`Sno`可以单独推断出`(Sname, Statu)`，这就导致其存在插入异常和删除异常的问题：
- 插入异常：是指按照关系模式实体完整性不能取空值或部分取空值。
  - 由于候选码只有一个，所以`(Sno,Pno)`也是主码。这样当某个供应商的`Pno`未提供，则不能插入数据。
- 删除异常：
  - 若供应商S3的P2零件销售完以后不再售卖，那么应删除元组，可S3又是客观存在的，不能因此删除。

为了消除部分函数依赖，我们可以将SPART关系分解为：
- `SupplierInfo(Sno, Sname, Status, City)`
- `Part(Sno, Pno, Qty)`

分解后的关系模式`Supplier`的码为`Sno`，非主属性`Sname`，`Status`，`City`完全依赖于`Sno`，所以属于**2NF**；

关系模式`Part`的码为`(Sno,Pno)`，非主属性`Qty`完全依赖于码，所以也属于**2NF**。

#### 第三范式（3NF）

- 定义：在2NF的基础上，**消除**非主属性之间的**传递依赖**，即任何**非主键列**都**不依赖**于其它**非主键**列。
- 目的：消除**传递依赖**，提高数据表的稳定性和一致性。

在满足了2NF之后，继续分析可以发现，关系`SupplierInfo`中存在**传递函数依赖**。
- `Sno->Status`和`Status->City`

导致其存在修改操作的不一致性问题：
- 如Status=20对应的City从天津搬到了上海，则有可能导致一些Status=20的数据被修改，而另一些不被修改，导致数据产生不一致性。
  
为了解决这个问题，就需要3NF。将`SupplierInfo`进一步分解：
- `Supplier_1(Sno, Sname, Status)`
- `Supplier_2(Status, City)`


#### 巴斯-科德范式（BCNF）

- 定义：在3NF的基础上，要求任何**非主键**列**不依赖**于**主属性**的**子集**。
- 目的：消除3NF中**主属性**对码的**部分依赖**和**传递依赖**。
  
假设：(这个例子可能并不够贴切)
- 某公司有若干仓库，
- 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
- 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。
- 每种物品在每个仓库中都有对应的数量。

表格数据如下：

|仓库|管理员|物品|数量|
|-|-|-|-|
|上海仓|张三|iPhone|30|
|上海仓|张三|iPad|20|
|广州仓|李四|小米13|50|
|北京仓|李四|华为Mate|30|

那么关系模式 `仓库表(仓库，管理员，物品名，数量)` 属于哪一级范式？

分析：
- 函数依赖：
  - `(仓库,物品) -> (管理员, 数量)` 
  - `(管理员, 物品) -> (仓库,数量)`
- 候选键：
  - `(仓库, 物品)` 
  - `(管理员，物品)`
- 主属性：
  - `仓库`
  - `管理员`
  - `物品名`
- 非主属性：
  - `数量`

非主属性完全依赖于候选键，**不存在**非主属性对候选键的**部分函数依赖**（满足2NF），也不存在**传递依赖**，所以它满足**3NF**。

但这个表存在如下问题：
1. 增加一个仓库，但没有存放物品，管理员信息也无法插入。
2. 清空仓库中的所有物品，同时把仓库、管理员信息也清掉了。

这是因为主属性`管理员`对候选键`(仓库，物品)`存在部分依赖，或者说`仓库`对`(管理员, 物品)`存在部分依赖，继续拆分表格来满足BCNF：
- `仓库(仓库名，管理员)`
- `库存(仓库，物品，数量)`


#### 第四范式（4NF）

- 定义：在满足3NF基础上，**消除**非平凡的**多值依赖**。
- 目的：处理表中**多**个**独立存在**的**多值关系**。

假设存在下表：

|学生编号|选课|爱好|
|--|--|--|
|1|数学|篮球|
|1|数学|羽毛球|
|1|英语|篮球|
|1|英语|羽毛球|

在该表中，候选键为`(学生编号,选课,爱好)`，即全部属性都是主属性，且不存在函数依赖，所以它是满足BNCF。

但是由于`学生编号`与`选课`之间，`学生编号`与`爱好`之间分别存在多值依赖，且`选课`和`爱好`之间没有任何关系，所以这里存在数据冗余。每多一个选课都要添加2条记录（篮球和羽毛球）。

4NF的目的就是为了消除这种数据冗余，即**消除**关系中的**多对多**关系，将其**拆分为**多个**一对多**关系。

我们将上表拆分成两张表：
- `S_C(StudentId,Course)`
- `S_H(StudentId,Hobby)`
  
#### 第五范式（5NF）

- 定义：在4NF基础上，处理半依赖和连接依赖。
- 目的：保证数据表中没有隐含的依赖关系。

在4NF的例子中，如果补充一点约束：只有爱好为篮球的学生才可以选择数学和语文，只有爱好为羽毛球的学生才可以选择英语和化学。

此时学生编号、爱好和选课三个属性之间任意两个属性都存在多值约束，此时这三个属性就变成了连接依赖，不存在多值依赖，也就自然满足了4NF，而在4NF基础上，进一步消除其不由候选码隐含的连接依赖，就得到了5NF。

**消除其不由候选码隐含的连接依赖**：保证不存在任何依赖属性不为候选码的连接依赖。

例如上面所述的关系中，候选码是(学生编号，选课，爱好)，而在其连接依赖中：
- 学生编号->选课和学生编号->爱好之间的连接属性为学生编号；
- 爱好->选课和学生编号->爱好之间的连接属性为爱好；
- 爱好->选课和学生编号->选课之间的连接属性为选课；

可见它们的连接属性都不是候选码，所以不满足5NF。

为了使其满足5NF，我们需要针对其连接依赖进行拆分：
- R1(学生编号,选课)。
- R2(学生编号,爱好)和R3(选课,爱好)。

#### 总结

|范式|解析|
|--|--|
|1NF|每一列都不可分割|
|2NF|消除**部分依赖**|
|3NF|消除**传递依赖**|
|BCNF|消除**主属性**对码的**部分依赖**和**传递依赖**|
|4NF|消除**多值依赖**|


### 五、反规范化

在关系模式的**规范化**过程中，会导致**关系**的概念越来越**单一化**，在响应用户查询时，往往需要涉及**多表**的**连接**操作，导致查询**性能下降**。

为此需要对关系模式进行修正，对部分影响性能的关系模式进行处理。包括分解、合并、增加冗余属性等。这种修正称为反规范化设计。

反规范化设计通过有意地违反数据库设计中的范式原则，将**数据冗余**存储在多个表中，通过**减少**表之间的**连接**来提高查询性能。

反规范化设计不应与从未进行过标准化的数据库相混淆。常见的反规范化操作有：
- 列：
  - **冗余列**：在多个表中存储相同的列，以避免连接操作。
  - **派生列**：将需要计算的列存储在表中，以避免计算开销。
- 表：
  - **表重组**：将多个表合并成一个表，以减少连接操作。
  - **表分割**：
    - 水平分割
    - 垂直分割

#### 总结
- 冗余**相同列**，派生**计算列**，减少连接与计算。
- 眼光从列放到表:
  - **表多**可合并**重组**。
  - **量多**可行列**分割**。
    - 行分割分维度分压力，
    - 列分割列主码分不同。
  

反规范化设计会在数据库中形成数据冗余，为解决**数据冗余**带来的**数据不一致**问题，设计人员往往需要采用**额外数据同步**的方法来解决数据不一致性。常见的方法有：

  - 事务控制：通过事务机制确保数据修改操作的原子性、一致性、隔离性和永久性。
  - 定期批量处理同步：通过定时批处理程序定时将相关表的冗余数据进行更新，确保数据一致性。
  - 触发器同步：是指在数据修改操作发生时自动触发响应的更新操作，保持数据一致性。


#### 冗余列

#### 派生列

#### 表重组

#### 表分割

表分隔是指将一个大表根据某些特定条件分隔成多个小表。每个小表只包含部分数据，但这些小表共同构成原来的大表。

这种方法可以有效地利用分布式数据库系统的特性，通过将数据分布在不同的服务器上，可以显著地提高查询性能和数据处理能力。

##### 水平分割

水平分割是根据数据行的特点进行分割，分割之后所得的所有表的结构都相同，而存储的数据不同。

例如我国的身份证号码若放在一个表中，由于我国人口众多，因此数据量很大，进行身份查询的效率会很低。这是可以按省份对它进行水平分割，把不同区域的身份信息存储在不同的表中，查询时只需根据省份代码查询相应的表，显著提高查询效率。

水平分割会增加应用的复杂度，特别是汇总数据时需要从不同的表或库中合并。有时候这种复杂性会超过它所带来的有点因此，综合考量表中数据具备很好的独立性时，就适合采用这种办法。

##### 垂直分割

垂直分割是根据数据列的特点进行分割，分割之后所得的所有表都含有主码列外其余列都不相同。

一般在一个表中某些列常用，而某些列不常用时采取垂直分割，把常用列和不常用列分开存储，从而提高查询效率。自然其缺点是若需汇总数据，则需要使用类似join的操作进行合并。


## 6.系统架构设计基础知识
### 6.1 软件架构设计的概念及生命周期
软件架构设计是指通过一系列的设计活动，获得满足系统 功能性需求，符合 **一定非功能性需求** 与 质量属性有相似含义的系统框架模型。

*ps：在架构设计中，主要考虑非功能性需求。*

软件架构设计的 **经验总结** 和 **重用** 是软件工程的重要目标之一。所采用的手段：
- 体系结构风格（*也就是 软件架构风格*）
- DSSA（*特定领域的软件架构*）

#### 软件架构设计的生命周期

> 口诀： 需计时、走不开

|阶段|要点|解释|
|-|-|-|
|需求分析|将需求模型 转换 软件架构模型；保证转换的可追踪性|用例模型 -> 功能模型|
|设计阶段|架构模型的描述、设计与分析、经验总结与复用|软件架构的基本概念、体系结构描述语言（*ADL，Architecture Description Language*）、架构模型的多视图表示（*4+1视图*）|
|实现阶段|基于架构的开发支持、实现途径、测试技术||
|构件组装阶段|组装过程要考虑**失配**问题:1.构件失配；2.连接件适配；3.全局体系架构的冲突引起的失配||
|部署阶段|软硬件模型、部署方案||
|后开发阶段|软件部署之后的维护、演化、复用|动态软件体系结构、体系结构的恢复与重建|


### 6.2 基于架构的软件开发方法（ABSD）
ABSD方法是构成软件的**体系结构来驱动**整个软件的开发过程。

体系结构的组成：
- **商业**（*商业需求，降低成本、提高效率、增加竞争力*）
- **质量**（*质量需求，如性能、可用性、安全性、可修改性*）
- **功能需求**

在ABSD中，用 **视角与视图** 描述软件架构、用 **质量场景** 来描述质量需求、用 **用例** 来描述功能需求。

ABSD是一个 **自顶向下**、**递归细化**的方法，软件的体系结构通过该方法得到细化，直到能产生 构件 和 类。

ABSD有三个基础：
1. 系统功能的分解。
   - 使用已有的基于模块的内聚和耦合技术
2. 架构风格的选择。
   - 选择合适的架构风格实现质量和商业需求
3. 强调软件模板的使用。

采用ABSD方法，设计活动可以从 项目总体功能框架明确后 就开始，因此该方法特别适用于：开发一些不能预先决定所有需求的软件系统，如产品线系统、长生命周期系统，也可为需求不能在短时间内明确的软件项目提供指导。


#### ABSD的过程

> 口诀：需记文、复誓言

|过程|要点|输出|
|-|-|-|
|体系结构需求|需求获取（*类似的从需求库取*）、标识构件（*类图、类分组、类打包成构件*）、需求评审|需求规格说明书（SRS）|
|体系结构设计|架构模型、构件映射、构件作用分析、设计评审|产生架构|
|体系结构文档化|使用者角度、分发所有开发、保持最新|**架构（体系结构）规格说明**、测试架构需求的**质量设计说明书**|
|体系结构复审|主要由外部人员复审，发现潜在的风险和错误||
|体系结构实现|用实体显示出架构|分析与设计、构件实现、构件组装、系统测试|
|体系结构演化|对架构进行改变、按需增删架构，使架构可复用|需求变化、架构演化计划、构件变动、更新后构件的相互作用、重新组装与测试、评审、演化后的架构|


### 6.3 架构风格
软件架构风格是描述某一特定领域中**系统组织方式**的**惯用模式**。

软件架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。

> 这里的**语义特性**是指：架构风格所包含的领域特定的含义、交互规则和行为约束。

#### 主要特征（架构定义、架构词汇表、架构约束）
架构风格定义了一类架构所共有的特征，主要包括：
- 架构定义
- 架构**词汇表**
- 架构**约束**
  

##### 架构定义
...

##### 架构词汇表
架构词汇表定义了架构中允许使用的组件类型（****）和连接器类型。

##### 架构约束
架构约束定义了组件和连接器之间的合法关系和行为规则。
- 组件约束：
  - 定义组件的行为和属性。例如，组件必须提供特定的接口，组件的状态必须满足某些条件等。
- 连接器约束：
  - 定义连接器的行为和属性。例如，连接器必须支持特定的通信协议，连接器的延迟必须在一定范围内等。
- 配置约束：
  - 定义组件和连接器之间的合法配置。例如，某些类型的组件只能通过特定类型的连接器通信，某些组件不能直接通信等。

##### 举例
1. 分层架构：
   - 词汇表：
     - 组件：`表示层`、`业务层`、`持久层`、`数据层`。
     - 连接器：`接口调用`、`数据库查询`。
   - 约束：
     - 组件约束：每一层只能与其相邻层通信，不能跳过中间层直接通信。
     - 连接器约束：表示层只能通过`接口调用`业务层，业务层只能通过接口调用持久层，持久层只能通过`数据库查询`数据层。
     - 配置约束：`表示层`不能直接访问`数据层`，必须通过`业务层`和`持久层`。

2. 事件驱动架构：
   - 词汇表：
     - 组件：`事件生产者`、`事件处理器`。
     - 连接器：`事件队列`、`事件通道`。
   - 约束：
     - 组件约束：`事件生产者`负责生成事件，`事件处理器`负责处理事件。
     - 连接器约束：`事件队列`负责接收和存储事件，`事件通道`负责分发传输事件到`事件处理器`。
     - 配置约束：`事件生产者`通过`事件队列`、`事件通道`与`事件处理器`通信，不能直接调用。

3. 微服务架构：
   - 词汇表：
     - 组件：独立的`服务`。
     - 连接器：`HTTP/REST`、`消息队列`
   - 约束：
     - 组件约束：每个`服务`必须是独立部署的单元，每个服务负责一个特定的业务功能。
     - 连接器约束：`服务`之间通过`HTTP/REST`或`消息队列`进行通信，通信协议必须标准化。
     - 配置约束：`服务`之间必须松耦合，`服务`的变更不应影响其他服务的正常运行。

#### 架构风格一览表

|架构风格|要点|优点|缺点|典型实例|
|-|-|-|-|-|
|数据流风格|每个阶段的结果是下一阶段的输入|1.高内聚、低耦合（*同时衍生出良好的重用性、维护性、隐蔽性*）；2.可拓展性|1.交互性差；2.复杂性高；|传统编译器、网络报文处理|
||以整体的方式传递，一步接一步|||批处理|
||步骤通过数据流链接，每个处理步骤由过滤器实现，处理步骤间的数据传输由管道负责|2.管道过滤器风格支持并行|3.性能差（*每个过滤器需要解析与合成数据*）|管道-过滤器|
|调用/返回风格（*显示调用*）|采用调用-返回机制|1.良好的重用性（*接口不变就能复用*）；2.可维护性好；3.可拓展性好|分层很难（*1.并不是每个系统都能分层；2.对层进行抽象的方法难找；3.耦合性高的系统分层困难*）||
||显示的函数调用|||主程序/子程序风格|
||对象是构件，连接件是接口、封装的方法|||面向对象风格|
||OSI-7层模型，各层次间通过协议连接，每层最多影响上、下两层|||层次风格|
||服务调用|||C/S架构|
|独立构件风格|进程通信风格、事件驱动风格（*隐式调用*）|1.松耦合。2.良好的复用性/可修改性/可拓展性|1.构件放弃了对系统计算的控制。2.数据交换问题。||
||进程间独立的消息传递，可同步、异步|||进程通信风格|
||隐式调用，通过事件触发。如语法高亮、错误提示||3.过程的语义必须依赖被触发事件的上下文约束，正确性的推理存在问题（?）|事件驱动风格|
|虚拟机风格|在自建环境上解析和运行自定义的规则|灵活应对自定义场景|复杂度高||
||适用于自定义规则的场合|高级语言解释引擎||解释器风格|
||规则为中心的风格在解释器基础上增加经验规则|决策支持系统、专家系统、人工智能||基于规则的风格|
|仓库风格（以数据为中心）|数据共享||||
||现代编译器的集成开发环境（IDE）、数据库系统|||仓库风格|
||信号处理领域如语音识别、问题求解|||黑板风格|
|||||超文本|
|闭环结构（*过程控制*）|软、硬件之间存在一个反馈循环。反馈循环接受一定输入，确定一定输出，再达到一个新的状态|||空调恒温机制、汽车定速巡航|
|C2风格|通过 连接件 绑定而运作的并行 构件 网络|||插件系统|
|MDA风格|模型驱动，CIM->PIM->PSM->可执行代码||||

> - 优点 主要以 性能、复用性、拓展性、可维护性等方面考量
> - 缺点 从 易用性、复杂性方面考量。
> - C2：构件（Component）、连接件（Connector）
> - MDA：Model-Driven Architecture，模型驱动架构
> - CIM: Computation-Independent Model，计算无关模型
> - PIM: Platform-Independent model，平台无关模型
> - PSM: Platform-Specific Model，平台相关模型

### 基于规则的系统
#### 整体流程(7步走)

|步骤|描述|
|---|---|
|1|需求分析|
|2|规则定义|
|3|规则引擎选择|
|4|规则存储与检索|
|5|规则执行|
|6|规则更新与维护|
|7|性能评估与优化|

##### 1.需求分析
在这一步需要明确系统需要实现的功能和规则。例如，一个贷款审批系统需要根据申请人的年龄、收入、信用记录等条件来判断是否批准贷款。
##### 2.规则定义
定义规则是实现基于规则系统的关键。规则通常以 `如果…那么…` 的形式表达。例如：

```
if age > 18 and income > 30000 and credit_score > 700:
  approve_loan()
```

##### 3.规则引擎选择
选择一个合适的规则引擎对于实现基于规则的系统至关重要。常见的规则引擎有Drools、Jess等。

##### 4.规则存储与检索
规则需要存储在某种形式的存储系统中，如数据库或文件系统。以下是一个简单的规则存储示例：

```json
rules = [
  {
    "condition": "age > 18", 
    "action": "approve_loan"
  }
]
```

##### 5.规则执行
在这一步，我们需要编写代码来执行定义好的规则。以下是一个简单的规则执行示例：

```
def execute_rules(person):
  for rule in rules:
    if eval (rule["condition"]):
      eval (rule["action"])
```


##### 6.规则更新与维护
##### 7.规则评估与优化
